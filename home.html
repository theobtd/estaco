<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Estaco</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
  <style>
    :root {
      --estaco-primary: #8B8E6F; /* Light olive */
      --estaco-primary-light: #A7A98C; /* Lighter olive for hover states */
      --estaco-secondary: #E2725B; /* Soft terracotta */
      --estaco-accent: #FFD700; /* Warm yellow (for buttons, accents) */
      --estaco-background: #FFFFFF;
      --estaco-surface: #F9F9F9;
      --estaco-text: #333333;
      --estaco-text-light: #666666;
      --estaco-border: #E0E0E0;
      --estaco-error: #F44336;
      --estaco-success: #4CAF50;
    }

    body {
        font-family: Arial, sans-serif;
        max-width: 100%; /* Remove fixed max-width */
        margin: 0;
        padding: 0; /* Remove padding to allow full-width media */
        padding-bottom: 60px;
        padding-top: 60px;
    }
    #post-form {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background-color: #ffffff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    #post-photo {
      width: 95%;
      padding: 8px;
      margin: 5px 0;
    }
    #post-content {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      resize: none;
      font-size: 15px;
      box-sizing: border-box;
    }
    input, textarea {
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    html, body {
      overflow-x: hidden;
      width: 100%;
    }
    #post-media-label {
      display: inline-flex;
      align-items: center;
      padding: 10px 15px;
      background: var(--estaco-surface);
      color: var(--estaco-text);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
      transition: background-color 0.2s;
    }
    #post-button {
      padding: 10px 20px;
      background-color: var(--estaco-primary); /* Light olive */
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .post-form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    #feed {
      margin-top: 20px;
      width: 100%;
    }
    .post {
      padding: 10px;
      border: 1px solid var(--estaco-border);
      border-radius: 5px;
      margin-bottom: 10px;
      margin-left: 0;
      margin-right: 0;
      background: var(--estaco-background);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    #error-message {
      color: red;
    }
    .post-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .post-author-picture {
      width: 40px;
      height: 40px;
      border-radius: 15%;
      margin-right: 10px;
    }
    .reactions {
      margin-top: 10px;
    }
    .reaction-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-right: 5px;
    }
    .reaction-count {
      font-size: 12px;
      margin-left: 3px;
      color: #666;
    }
    .reaction-button.selected {
      background-color: var(--estaco-primary);
      color: white;
      border-radius: 4px;
      padding: 2px 4px;
    }
    .comments-section {
      margin-top: 10px;
      border-top: 1px solid var(--estaco-border);
      padding-top: 10px;
    }
    .comment-form {
      display: flex;
      margin-bottom: 10px;
    }
    .comment-input {
        flex: 1;
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        min-height: 40px;
        outline: none;
    }
    
    .comment-input:empty::before {
        content: attr(data-placeholder);
        color: #999;
        pointer-events: none;
        display: block;
    }
    .comment-button {
      padding: 8px 12px;
      background: var(--estaco-accent);
      border: none;
      border-radius: 4px;
      margin-left: 5px;
      cursor: pointer;
    }
    .comment {
      display: flex;
      margin-bottom: 8px;
      align-items: flex-start;
    }
    .comment-author-picture {
      width: 30px;
      height: 30px;
      border-radius: 10%; /* Adjust this value to control the roundness */
      margin-right: 8px;
    }
    .comment-content {
      background: var(--estaco-surface);
      padding: 8px 12px;
      border-radius: 8px;
      flex: 1;
    }
    .comment-author-name {
      font-weight: bold;
      margin-bottom: 2px;
    }
    .post-timestamp {
      text-align: right;
      font-size: 12px;
      color: var(--estaco-text-light);
      margin-top: -15px; /* Adjust as needed to move it closer to the header */
    }
    .media-container {
      position: relative;
      margin-top: 10px;
      overflow: hidden;
      background-color: var(--estaco-surface);
    }
    .media-horizontal,
    .media-vertical {
      width: 100%; /* Full width of the parent container */
      height: auto; /* Let height be calculated based on aspect ratio */
      position: relative;
      overflow: hidden;
      background-color: transparent; /* Remove grey background */
      margin: 0; /* Remove any default margins */
    }
    
    /* Horizontal media: 4:3 aspect ratio */
    .media-horizontal {
        aspect-ratio: 16 / 9;
    }
    
    /* Vertical media: 3:4 aspect ratio */
    .media-vertical {
        aspect-ratio: 3 / 4;
    }
    
    /* Media inside the container */
    .media-container img,
    .media-container video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* Use cover to fill the container */
    }
    .orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .orientation-button.selected {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }
    .delete-post-button {
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .crop-orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .crop-orientation-button.selected {
      background: var(--estaco-primary);
      color: white;
      border-color: var(--estaco-primary);
    }
    #image-preview-container {
        display: none;
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f9f9f9;
    }
    #image-preview {
        max-width: 100%;
        max-height: 200px;
        border-radius: 4px;
        display: block;
        margin: 0 auto;
    }
    #post-media {
        display: none;
    }
    .video-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
    }
    
    .custom-play-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .custom-play-button.hidden {
        display: none;
    }

    #bottom-nav-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
      background-color: white;
      border-top: 1px solid #e0e0e0;
      padding: 8px 0;
      z-index: 100;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
    }
    
    .nav-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      color: #333;
      font-size: 12px;
    }
    
    .nav-button .icon {
      font-size: 24px;
      margin-bottom: 4px;
    }
    
    .nav-button .label {
      font-size: 12px;
    }

    #top-nav-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: white;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 0;
      z-index: 100;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }
    
    #top-nav-bar h1 {
      margin: 0;
      font-size: 24px;
      color: var(--estaco-primary);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid #1877f2;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #crop-done-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #crop-cancel-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }

    #upload-overlay {
      display: flex;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .see-comments-button {
      padding: 8px 12px;
      background: var(--estaco-surface);
      border: 1px solid var(--estaco-border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      color: var(--estaco-text-light);
      margin-top: 8px;
      transition: background-color 0.2s;
    }
    
    .see-comments-button:hover {
      background: var(--estaco-primary-light);
    }
    
    .comments-list {
      display: none;
    }
    
    .comments-list.visible {
      display: block;
    }

    .comments-loading {
      display: none;
      width: 100%;
      text-align: center;
      padding: 10px 0;
    }
    
    .comments-loading .spinner {
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top: 2px solid var(--estaco-primary);
      width: 20px;
      height: 20px;
      animation: spin 0.8s linear infinite;
      margin: 0 auto;
    }

    #user-tag-dropdown {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      width: 200px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .user-tag-item {
      padding: 8px;
      cursor: pointer;
    }
    
    .user-tag-item:hover {
      background: #f0f0f0;
    }

    .tag-validated {
      background-color: var(--estaco-primary-light);
      color: var(--estaco-text);
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: 500;
      white-space: nowrap;
    }

    #post-content:empty::before {
      content: attr(data-placeholder);
      color: #999;
      pointer-events: none;
      display: block;
    }

    .respond-button {
      background: none;
      border: none;
      color: var(--estaco-secondary);
      cursor: pointer;
      font-size: 12px;
      margin-top: 4px;
      padding: 0;
      text-decoration: underline;
    }

    .reaction-popup {
      display: none;
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: white;
      border-top-left-radius: 16px;
      border-top-right-radius: 16px;
      box-shadow: 0 -4px 20px rgba(0, 0, 0, 0.15);
      padding: 20px;
      height: 66vh;
      z-index: 3000;
      animation: slideUp 0.3s ease-out forwards;
    }
    
    .reaction-popup-content {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100%;
      text-align: center;
      position: relative;
    }
    
    .reaction-popup-content p {
      font-size: 18px;
      margin: 0;
      color: var(--estaco-text);
    }
    
    .close-reaction-popup-button {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #FFCDD2; /* Pastel red */
      color: var(--estaco-error);
      border: none;
      cursor: pointer;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: background 0.2s;
    }
    
    .close-reaction-popup-button:hover {
      background: #EF9A9A; /* Slightly darker pastel red */
    }
    
    @keyframes slideUp {
      from {
        transform: translateY(100%);
      }
      to {
        transform: translateY(0);
      }
    }
    
    @keyframes slideDown {
      from {
        transform: translateY(0);
      }
      to {
        transform: translateY(100%);
      }
    }

    .reaction-list {
      width: 100%;
      max-height: 70vh;
      overflow-y: auto;
      margin-top: 10px;
    }
    
    .reaction-list p {
      font-size: 16px;
      color: var(--estaco-text-light);
      text-align: center;
      margin-top: 20px;
    }
    
    .reaction-item {
      display: flex;
      align-items: center;
      padding: 10px;
      border-bottom: 1px solid var(--estaco-border);
    }
    
    .reaction-icon {
      font-size: 20px;
      margin-right: 10px;
    }
    
    .reaction-username {
      font-size: 16px;
      color: var(--estaco-text);
    }

    #visibility-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 1000;
      justify-content: center;
      align-items: center;
    }
    
    #visibility-modal > div {
      max-width: 500px;
      margin: 20px auto;
      background: white;
      padding: 20px;
      border-radius: 10px;
      max-height: 80vh;
      overflow-y: auto;
    }
    
    #friends-list {
      list-style: none;
      padding: 0;
    }
    
    #friends-list li {
      padding: 8px;
      border-bottom: 1px solid #eee;
    }
    
    #close-visibility-modal {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    .friend-toggle {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: #ddd;
      border: none;
      cursor: pointer;
      margin-left: 10px;
      float: right;
    }
    
    .friend-toggle.active {
      background-color: var(--estaco-primary);
    }
    #select-all-friends {
      padding: 8px;
      border-bottom: 1px solid #eee;
      font-weight: bold;
    }
    
    #select-all-toggle {
      width: 20px;
      height: 20px;
      border-radius: 50%;
      background-color: var(--estaco-primary);
      border: none;
      cursor: pointer;
      margin-left: 10px;
      float: right;
    }

  </style>
</head>
<body>
  <div id="top-nav-bar">
    <h1>Estaco</h1>
  </div>

  <div id="post-form">
    <h3 data-i18n="Create a Post">Create a Post</h3>
    <div
      id="post-content"
      contenteditable="true"
      data-placeholder="How's life treating ya?"
      style="
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        resize: none;
        font-size: 15px;
        box-sizing: border-box;
        min-height: 60px;
        outline: none;
      "
    ></div>
    <div class="post-form-actions">
      <label for="post-media" id="post-media-label">
        <span data-i18n="Photo/Video">üì∑ Photo/Video</span>
      </label>
      <button id="visibility-button" data-i18n="Visibility">Visibility</button>
      <button id="post-button" data-i18n="Post">Post</button>
    </div>
    <input type="file" id="post-media" accept="image/*,video/*" style="display: none;">
    <div id="image-preview-container" style="display: none; margin: 10px 0;">
      <img id="image-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;">
    </div>
    <div id="video-preview-container" style="display: none; margin: 10px 0;">
      <video id="video-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;" controls></video>
    </div>
    <div id="post-loading" style="display: none; text-align: center; margin: 10px 0;">
      <div class="spinner"></div>
    </div>
    <p id="error-message"></p>
  </div>
  
  <div id="image-cropper-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000;">
    <div style="max-width: 500px; margin: 20px auto; background: white; padding: 20px; border-radius: 10px;">
      <h3 data-i18n="Adjust Image">Adjust Image</h3>
      <div style="margin-bottom: 10px;">
        <button class="crop-orientation-button selected" data-orientation="horizontal" data-i18n="Horizontal">Horizontal</button>
        <button class="crop-orientation-button" data-orientation="vertical" data-i18n="Vertical">Vertical</button>
      </div>
      <div style="width: 100%; height: 400px;">
        <img id="cropper-image" style="max-width: 100%;">
      </div>
      <button id="crop-done-button" data-i18n="Done">Done</button>
      <button id="crop-cancel-button" data-i18n="Cancel">Cancel</button>
    </div>
  </div>
  
  <div id="feed">
    <h3 data-i18n="Your Feed">Your Feed</h3>
  </div>
  
  <div id="bottom-nav-bar">
    <button class="nav-button" id="home-button">
      <span class="icon">üè†</span>
      <span class="label" data-i18n="Feed">Feed</span>
    </button>
    <button class="nav-button" id="notifications-button">
      <span class="icon">üîî</span>
      <span class="label">Notifications</span>
    </button>
    <button class="nav-button" id="profile-button">
      <span class="icon">üë§</span>
      <span class="label" data-i18n="Profile">Profile</span>
    </button>
  </div>

  <div id="upload-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div class="spinner"></div>
  </div>

  <div id="user-tag-dropdown" style="display: none; position: absolute; background: white; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; z-index: 1000; width: 200px;"></div>

  <div id="reaction-popup" class="reaction-popup">
    <div class="reaction-popup-content">
      <button id="close-reaction-popup" class="close-reaction-popup-button">√ó</button>
      <h3>Reactions to your post</h3>
      <div id="reaction-list" class="reaction-list">
        <!-- Reactions will be inserted here -->
      </div>
    </div>
  </div>

  <div id="visibility-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; justify-content: center; align-items: center;">
    <div style="max-width: 500px; margin: 20px auto; background: white; padding: 20px; border-radius: 10px; max-height: 80vh; overflow-y: auto;">
      <h3 data-i18n="Who can see your post?">Who can see your post?</h3>
      <p data-i18n="This post will be visible to:">This post will be visible to:</p>
      <ul id="friends-list" style="list-style: none; padding: 0;"></ul>
      <button id="close-visibility-modal" data-i18n="Close">Close</button>
    </div>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-functions-compat.js"></script>
  <script>
    // Your Firebase config (replace with your own)
    const firebaseConfig = {
      apiKey: "AIzaSyB1txjASKb_6VPhKBpQh_Y3hoPHsNWwZ_0",
      authDomain: "estaco-add3c.firebaseapp.com",
      projectId: "estaco-add3c",
      storageBucket: "estaco-add3c.firebasestorage.app",
      messagingSenderId: "876337002297",
      appId: "1:876337002297:web:b410c373bd857bc7cd1ae8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();
    const functions = firebase.functions();

    // DOM elements
    const postContent = document.getElementById('post-content');
    const postMedia = document.getElementById('post-media');
    const postButton = document.getElementById('post-button');
    const feed = document.getElementById('feed');
    const errorMessage = document.getElementById('error-message');

    let isLoading = false; // Flag to prevent multiple simultaneous loads
    let isVisibilityAll = true; // Default: all friends selected
    
    // Navigate to Profile Page
    document.getElementById('profile-button').addEventListener('click', () => {
      window.location.href = 'profile.html';
    });

    document.getElementById('notifications-button').addEventListener('click', () => {
      window.location.href = 'notifications.html';
    });
    
    document.getElementById('home-button').addEventListener('click', () => {
      window.location.href = 'home.html'; // or reload the current page
    });

    async function renderNewPost(post) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Get the author's profile picture
      const profilePictureHTML = await getCommentAuthorPicture(post.authorId, post.authorName);
    
      // Process post content for @username tags
      let processedContent = post.content;
      
      // Construct the post HTML
      let mediaHTML = '';
      if (post.photoURL) {
        const orientation = post.mediaOrientation || 'horizontal';
        mediaHTML = `
          <div class="media-container media-${orientation}">
            <img src="${post.photoURL}" class="post-media">
          </div>
        `;
      } else if (post.videoURL) {
        const orientation = post.mediaOrientation || 'horizontal';
        mediaHTML = `
          <div class="media-container media-${orientation}">
            <video controls class="post-media" playsinline webkit-playsinline>
              <source src="${post.videoURL}" type="video/mp4">
            </video>
          </div>
        `;
      }
    
      const postHTML = `
        <div class="post" data-post-id="${post.id}">
          <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center;">
              ${profilePictureHTML}
              <h4 style="margin: 0;">${post.authorName}</h4>
            </div>
            <div style="display: flex; align-items: center;">
              <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp)}</span>
              <button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>
            </div>
          </div>
          <p>${processedContent}</p>
          ${mediaHTML}
          <div class="reactions">
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="like">üëç</button>
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è</button>
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="laugh">üòÇ</button>
          </div>
          <div class="comments-section">
            <div class="comment-form">
              <div
                class="comment-input"
                contenteditable="true"
                data-placeholder="Write a comment..."
                data-post-id="${post.id}"
              ></div>
              <button class="comment-button" data-post-id="${post.id}">Post</button>
            </div>
          </div>
        </div>
      `;
    
      // Prepend the new post to the feed
      feed.insertAdjacentHTML('afterbegin', postHTML);
    }

    // Check if user is signed in and verified
    auth.onAuthStateChanged((user) => {
      if (!user || !user.emailVerified) {
        alert('Please sign in and verify your email to access the home feed.');
        window.location.href = 'index.html';
      } else {
        logUserFriendsWithPosts(user.uid); // Call the new function
        loadPosts();
    
        // Load user data from Firestore to get the user's language
        db.collection('users').doc(user.uid).get()
          .then((doc) => {
            if (doc.exists) {
              const userData = doc.data();
              userLanguage = userData.language || "English"; // Update globally
              updatePageLanguage(userLanguage);
            }
          })
          .catch((error) => {
            console.error("Error loading user data:", error);
          });
      }
    });

    // Global variables for the dropdown
    let currentInputElement = null;
    let currentAtPosition = -1;
    let currentQuery = "";
    
    // Function to show the dropdown with friends
    async function showUserTagDropdown(inputElement, query, atPos) {
      currentInputElement = inputElement;
      currentAtPosition = atPos;
      currentQuery = query;
    
      const dropdown = document.getElementById('user-tag-dropdown');
      dropdown.innerHTML = '';
    
      const user = auth.currentUser;
      if (!user) return;
    
      // Fetch the user's friends from Firestore
      const friendsDoc = await db.collection('friends').doc(user.uid).get();
      if (!friendsDoc.exists) return;
    
      const friends = friendsDoc.data()?.friends || [];
      const filteredFriends = friends.filter(friend =>
        friend.name.toLowerCase().includes(query.toLowerCase())
      );
    
      // Add each friend to the dropdown
      filteredFriends.forEach(friend => {
        const item = document.createElement('div');
        item.className = 'user-tag-item';
        item.textContent = friend.name;
        item.dataset.uid = friend.uid;
        item.addEventListener('click', () => {
          insertTaggedUser(currentInputElement, friend.name, currentAtPosition, friend.uid);
          hideUserTagDropdown();
        });
        dropdown.appendChild(item);
      });
    
      // Position the dropdown below the input
      const rect = inputElement.getBoundingClientRect();
      dropdown.style.display = 'block';
      dropdown.style.top = `${rect.bottom + window.scrollY}px`;
      dropdown.style.left = `${rect.left + window.scrollX}px`;
    }
    
    // Function to hide the dropdown
    function hideUserTagDropdown() {
      document.getElementById('user-tag-dropdown').style.display = 'none';
    }
    
    // Function to insert the selected user into the textarea
    function insertTaggedUser(inputElement, username, atPos, uid) {
      const text = inputElement.textContent;
      const before = text.substring(0, atPos);
      const after = text.substring(atPos + currentQuery.length + 1);
      const tag = `@${username}`;
      const highlightedTag = `<span class="tag-validated" contenteditable="false" data-uid="${uid}">${tag}</span>`;
    
      inputElement.innerHTML = before + highlightedTag + ' ' + after;
    
      // Move the cursor to the end of the tag
      const range = document.createRange();
      const selection = window.getSelection();
      const lastChild = inputElement.lastChild;
      range.setStartAfter(lastChild);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    
      inputElement.focus();
    }
    
    // Listen for @ in the post-content div
    postContent.addEventListener('input', (e) => {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const text = postContent.textContent;
      const cursorPos = range.startOffset;
    
      // Check if the character before the cursor is @ and not part of a tag
      if (cursorPos > 0 && text[cursorPos - 1] === '@') {
        const node = range.startContainer;
        let isInsideTag = false;
    
        // Check if the @ is inside a tag
        let currentNode = node;
        while (currentNode && currentNode !== postContent) {
          if (currentNode.classList && currentNode.classList.contains('tag-validated')) {
            isInsideTag = true;
            break;
          }
          currentNode = currentNode.parentNode;
        }
    
        if (!isInsideTag) {
          const lastAtPos = cursorPos - 1;
          const query = text.substring(lastAtPos + 1, cursorPos).trim();
          showUserTagDropdown(e.target, query, lastAtPos);
        } else {
          hideUserTagDropdown();
        }
      } else {
        hideUserTagDropdown();
      }
    });
    
    // Listen for clicks inside the post-content div
    postContent.addEventListener('click', (e) => {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const text = postContent.textContent;
      const cursorPos = range.startOffset;
      const lastAtPos = text.lastIndexOf('@', cursorPos - 1);
    
      if (lastAtPos !== -1 && cursorPos > lastAtPos) {
        const query = text.substring(lastAtPos + 1, cursorPos).trim();
        showUserTagDropdown(e.target, query, lastAtPos);
      } else {
        hideUserTagDropdown();
      }
    });
    
    // Listen for keypresses to detect backspace/delete
    postContent.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace' || e.key === 'Delete') {
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        const cursorNode = range.startContainer;
        const cursorOffset = range.startOffset;
    
        // Check if the cursor is inside a validated tag
        const tags = postContent.querySelectorAll('.tag-validated');
        let tagToRemove = null;
    
        tags.forEach(tag => {
          if (tag.contains(cursorNode) || tag === cursorNode) {
            tagToRemove = tag;
          }
        });
    
        if (tagToRemove) {
          e.preventDefault();
          const tagText = tagToRemove.textContent;
          const tagStart = postContent.textContent.indexOf(tagText);
          const tagEnd = tagStart + tagText.length;
          const before = postContent.textContent.substring(0, tagStart);
          const after = postContent.textContent.substring(tagEnd);
    
          postContent.textContent = before + after;
    
          // Move the cursor to the position after the removed tag
          const newRange = document.createRange();
          const newSelection = window.getSelection();
          newRange.setStart(postContent.firstChild, tagStart);
          newRange.collapse(true);
          newSelection.removeAllRanges();
          newSelection.addRange(newRange);
        }
      }
    });

    // Listen for @ in all comment inputs (event delegation)
    document.getElementById('feed').addEventListener('input', (e) => {
      if (e.target.classList.contains('comment-input')) {
        const commentInput = e.target;
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        const text = commentInput.textContent;
        const cursorPos = range.startOffset;
    
        // Check if the character before the cursor is @ and not part of a tag
        if (cursorPos > 0 && text[cursorPos - 1] === '@') {
          const node = range.startContainer;
          let isInsideTag = false;
    
          // Check if the @ is inside a tag
          let currentNode = node;
          while (currentNode && currentNode !== commentInput) {
            if (currentNode.classList && currentNode.classList.contains('tag-validated')) {
              isInsideTag = true;
              break;
            }
            currentNode = currentNode.parentNode;
          }
    
          if (!isInsideTag) {
            const lastAtPos = cursorPos - 1;
            const query = text.substring(lastAtPos + 1, cursorPos).trim();
            showUserTagDropdown(commentInput, query, lastAtPos);
          } else {
            hideUserTagDropdown();
          }
        } else {
          hideUserTagDropdown();
        }
      }
    });
    
    // Listen for clicks inside all comment inputs (event delegation)
    document.getElementById('feed').addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-input')) {
        const commentInput = e.target;
        const selection = window.getSelection();
        if (selection.rangeCount === 0) return;
        const range = selection.getRangeAt(0);
        const text = commentInput.textContent;
        const cursorPos = range.startOffset;
        const lastAtPos = text.lastIndexOf('@', cursorPos - 1);
    
        if (lastAtPos !== -1 && cursorPos > lastAtPos) {
          const query = text.substring(lastAtPos + 1, cursorPos).trim();
          showUserTagDropdown(commentInput, query, lastAtPos);
        } else {
          hideUserTagDropdown();
        }
      }
    });
    
    // Hide dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.matches('#post-content, .comment-input, .user-tag-item')) {
        hideUserTagDropdown();
      }
    });

    let originalImageFile = null;
    let lastCropOrientation = 'horizontal';

    // Create a new post
    postButton.addEventListener('click', () => {
      errorMessage.textContent = ''; // Clear any previous error message
      const content = postContent.innerHTML;
      const mediaFile = postMedia.files[0];
    
      if (!content) {
        alert(translations[userLanguage]["Post content cannot be empty."]);
        return;
      }
    
      // Show full-screen overlay
      document.getElementById('upload-overlay').style.display = 'flex';
      postButton.disabled = true;
    
      // NEW CHECK: Prevent tagging users who are not friends with each other
      const taggedUserUids = extractTaggedUserUids(content);
    
      if (taggedUserUids.length >= 2) {
        let allTaggedUsersAreFriends = true;
    
        // Check every pair of tagged users
        (async () => {
          for (let i = 0; i < taggedUserUids.length; i++) {
            for (let j = i + 1; j < taggedUserUids.length; j++) {
              const uid1 = taggedUserUids[i];
              const uid2 = taggedUserUids[j];
    
              const friendsOfUid1 = await getFriendUidsForUser(uid1);
              const friendsOfUid2 = await getFriendUidsForUser(uid2);
    
              // Check if uid2 is a friend of uid1 and vice versa
              if (!friendsOfUid1.includes(uid2) || !friendsOfUid2.includes(uid1)) {
                allTaggedUsersAreFriends = false;
                break;
              }
            }
    
            if (!allTaggedUsersAreFriends) {
              break;
            }
          }
    
          if (!allTaggedUsersAreFriends) {
            alert("You cannot tag users who are not friends with each other.");
            document.getElementById('upload-overlay').style.display = 'none';
            postButton.disabled = false;
            return; // Cancel the post creation
          }
    
          // Continue with post creation
          const user = auth.currentUser;
          user.reload().then(() => {
            const authorName = user.displayName || "Unknown User";
            const post = {
              authorId: user.uid,
              authorName: authorName,
              content: content,
              timestamp: firebase.firestore.FieldValue.serverTimestamp(),
              reactions: {}
            };
    
            db.collection('posts').add(post)
              .then((docRef) => {
                const uploadPromises = [];
                if (mediaFile) {
                  const storageRef = storage.ref();
                  const mediaType = postMedia.getAttribute('data-type');
                  const mediaRef = storageRef.child(`${mediaType}s/${docRef.id}`);
                  const uploadTask = mediaRef.put(mediaFile);
    
                  uploadPromises.push(
                    new Promise((resolve, reject) => {
                      uploadTask.on('state_changed',
                        null,
                        (error) => {
                          console.error('Upload error:', error);
                          reject(error);
                        },
                        () => {
                          uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                            const updateData = mediaType === 'image'
                              ? { photoURL: downloadURL, mediaOrientation: postMedia.getAttribute('data-orientation') }
                              : { videoURL: downloadURL, mediaOrientation: 'vertical' };
                            docRef.update(updateData).then(resolve);
                          });
                        }
                      );
                    })
                  );
                }
    
                Promise.all(uploadPromises)
                  .then(async () => {
                    alert('Post created!');
                    const user = auth.currentUser;
                    const authorName = user.displayName || "Unknown User";
                    const newPost = {
                      id: docRef.id,
                      authorId: user.uid,
                      authorName: authorName,
                      content: content,
                      timestamp: new Date(), // Use client-side date for immediate display
                      reactions: {},
                      photoURL: mediaFile && mediaFile.type.startsWith('image/') ? URL.createObjectURL(mediaFile) : null,
                      videoURL: mediaFile && mediaFile.type.startsWith('video/') ? URL.createObjectURL(mediaFile) : null,
                      mediaOrientation: postMedia.getAttribute('data-orientation') || 'horizontal'
                    };
                    renderNewPost(newPost);
    
                    // NEW LOGIC: Restrict post visibility to mutual friends if someone is tagged
                    const taggedUserUids = extractTaggedUserUids(content);
                    const posterUid = auth.currentUser.uid;
    
                    if (taggedUserUids.length > 0) {
                      for (const taggedUid of taggedUserUids) {
                        const mutualFriendUids = await getMutualFriendUids(posterUid, taggedUid);
                        const uidsToAddPost = [...new Set([...mutualFriendUids, posterUid, taggedUid])];
                        for (const uid of uidsToAddPost) {
                          await addPostToUserFeed(uid, docRef.id, new Date());
                        }
                      }
                    } else {
                      const friendUids = await getFriendUidsForUser(posterUid);
                      const uidsToAddPost = [...new Set([...friendUids, posterUid])];
                      for (const uid of uidsToAddPost) {
                        await addPostToUserFeed(uid, docRef.id, new Date());
                      }
                    }
    
                    // NEW: Add tag notifications for each tagged user
                    if (taggedUserUids.length > 0) {
                      for (const taggedUid of taggedUserUids) {
                        await addTagNotification(
                          taggedUid, // Tagged user's UID
                          docRef.id, // Post ID
                          user.uid, // Current user's UID (tagger)
                          user.displayName || "Unknown User", // Current user's name
                          firebase.firestore.FieldValue.serverTimestamp()
                        );
                      }
                    }
    
                    postContent.textContent = '';
                    postMedia.value = '';
                    document.getElementById('image-preview-container').style.display = 'none';
                    document.getElementById('video-preview-container').style.display = 'none';
                  })
                  .catch((error) => {
                    errorMessage.textContent = error.message;
                  })
                  .finally(() => {
                    // Reset the orientation button state to default (horizontal)
                    document.querySelectorAll('.crop-orientation-button').forEach(button => {
                      button.classList.remove('selected');
                    });
                    document.querySelector('.crop-orientation-button[data-orientation="horizontal"]').classList.add('selected');
    
                    // Hide full-screen overlay
                    document.getElementById('upload-overlay').style.display = 'none';
                    postButton.disabled = false;
                  });
              })
              .catch((error) => {
                errorMessage.textContent = error.message;
                // Hide loader
                document.getElementById('post-loading').style.display = 'none';
                postButton.disabled = false;
              });
          });
        })();
      } else {
        // Continue with post creation if less than 2 users are tagged
        const user = auth.currentUser;
        user.reload().then(() => {
          const authorName = user.displayName || "Unknown User";
          const post = {
            authorId: user.uid,
            authorName: authorName,
            content: content,
            timestamp: firebase.firestore.FieldValue.serverTimestamp(),
            reactions: {}
          };
    
          db.collection('posts').add(post)
            .then((docRef) => {
              const uploadPromises = [];
              if (mediaFile) {
                const storageRef = storage.ref();
                const mediaType = postMedia.getAttribute('data-type');
                const mediaRef = storageRef.child(`${mediaType}s/${docRef.id}`);
                const uploadTask = mediaRef.put(mediaFile);
    
                uploadPromises.push(
                  new Promise((resolve, reject) => {
                    uploadTask.on('state_changed',
                      null,
                      (error) => {
                        console.error('Upload error:', error);
                        reject(error);
                      },
                      () => {
                        uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                          const updateData = mediaType === 'image'
                            ? { photoURL: downloadURL, mediaOrientation: postMedia.getAttribute('data-orientation') }
                            : { videoURL: downloadURL, mediaOrientation: 'vertical' };
                          docRef.update(updateData).then(resolve);
                        });
                      }
                    );
                  })
                );
              }
    
              Promise.all(uploadPromises)
                .then(async () => {
                  alert('Post created!');
                  const user = auth.currentUser;
                  const authorName = user.displayName || "Unknown User";
                  const newPost = {
                    id: docRef.id,
                    authorId: user.uid,
                    authorName: authorName,
                    content: content,
                    timestamp: new Date(), // Use client-side date for immediate display
                    reactions: {},
                    photoURL: mediaFile && mediaFile.type.startsWith('image/') ? URL.createObjectURL(mediaFile) : null,
                    videoURL: mediaFile && mediaFile.type.startsWith('video/') ? URL.createObjectURL(mediaFile) : null,
                    mediaOrientation: postMedia.getAttribute('data-orientation') || 'horizontal'
                  };
                  renderNewPost(newPost);
    
                  // NEW LOGIC: Restrict post visibility to mutual friends if someone is tagged
                  const taggedUserUids = extractTaggedUserUids(content);
                  const posterUid = auth.currentUser.uid;
    
                  if (taggedUserUids.length > 0) {
                    for (const taggedUid of taggedUserUids) {
                      const mutualFriendUids = await getMutualFriendUids(posterUid, taggedUid);
                      const uidsToAddPost = [...new Set([...mutualFriendUids, posterUid, taggedUid])];
                      for (const uid of uidsToAddPost) {
                        await addPostToUserFeed(uid, docRef.id, new Date());
                      }
                    }
                  } else {
                    const friendUids = await getFriendUidsForUser(posterUid);
                    const uidsToAddPost = [...new Set([...friendUids, posterUid])];
                    for (const uid of uidsToAddPost) {
                      await addPostToUserFeed(uid, docRef.id, new Date());
                    }
                  }
    
                  // NEW: Add tag notifications for each tagged user
                  if (taggedUserUids.length > 0) {
                    for (const taggedUid of taggedUserUids) {
                      await addTagNotification(
                        taggedUid, // Tagged user's UID
                        docRef.id, // Post ID
                        user.uid, // Current user's UID (tagger)
                        user.displayName || "Unknown User", // Current user's name
                        firebase.firestore.FieldValue.serverTimestamp()
                      );
                    }
                  }
    
                  postContent.textContent = '';
                  postMedia.value = '';
                  document.getElementById('image-preview-container').style.display = 'none';
                  document.getElementById('video-preview-container').style.display = 'none';
                })
                .catch((error) => {
                  errorMessage.textContent = error.message;
                })
                .finally(() => {
                  // Reset the orientation button state to default (horizontal)
                  document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.classList.remove('selected');
                  });
                  document.querySelector('.crop-orientation-button[data-orientation="horizontal"]').classList.add('selected');
    
                  // Hide full-screen overlay
                  document.getElementById('upload-overlay').style.display = 'none';
                  postButton.disabled = false;
                });
            })
            .catch((error) => {
              errorMessage.textContent = error.message;
              // Hide loader
              document.getElementById('post-loading').style.display = 'none';
              postButton.disabled = false;
            });
        });
      }
    });


    let lastVisiblePost = null; // To keep track of the last fetched post
    const postLimit = 3; // Number of posts to load at a time
    let isFirstLoad = true; // Add this flag at the top with your other variables
    
    async function loadPosts() {
        if (isLoading) return; // Prevent multiple simultaneous loads
        isLoading = true;
    
        const user = auth.currentUser;
        if (!user) {
            isLoading = false;
            return;
        }
    
        try {
            // 1. Get the user's feed sub-collection
            const feedRef = db.collection(`users/${user.uid}/feed`);
            let query = feedRef.orderBy('postTimestamp', 'desc');
    
            if (lastVisiblePost) {
                query = query.startAfter(lastVisiblePost.data().postTimestamp);
            }
    
            // Load only 1 post on the first load, otherwise load postLimit
            if (isFirstLoad) {
                query = query.limit(1);
            } else {
                query = query.limit(postLimit);
            }
    
            const feedSnapshot = await query.get();
    
            if (feedSnapshot.empty) {
                if (!feed.querySelector('.post')) {
                    feed.innerHTML = '<p>No posts yet. Create one!</p>';
                } else {
                    feed.innerHTML += '<p>No more posts to load.</p>';
                }
                isLoading = false;
                return;
            }
    
            // 2. Fetch the actual post data for each post ID in the feed
            const postIds = feedSnapshot.docs.map(doc => doc.data().postId);
            const postsSnapshot = await db.collection('posts')
                .where(firebase.firestore.FieldPath.documentId(), 'in', postIds)
                .get();
    
            const postsData = [];
            const feedData = feedSnapshot.docs.map(doc => ({
                postId: doc.data().postId,
                CommentsVisible: doc.data().CommentsVisible || false,
            }));
    
            postsSnapshot.forEach((doc) => {
                const post = doc.data();
                post.id = doc.id;
                // Find the corresponding feed data
                const feedDoc = feedData.find(fd => fd.postId === post.id);
                if (feedDoc) {
                    post.CommentsVisible = feedDoc.CommentsVisible;
                }
                postsData.push(post);
            });
    
            // Sort postsData to match the feed order
            postsData.sort((a, b) => {
                const aFeedDoc = feedSnapshot.docs.find(doc => doc.data().postId === a.id);
                const bFeedDoc = feedSnapshot.docs.find(doc => doc.data().postId === b.id);
                return bFeedDoc.data().postTimestamp - aFeedDoc.data().postTimestamp;
            });
    
            // Update lastVisiblePost for pagination
            lastVisiblePost = feedSnapshot.docs[feedSnapshot.docs.length - 1];
    
            await renderPosts(postsData);
    
            // After the first load, set the flag to false and load more posts
            if (isFirstLoad) {
                isFirstLoad = false;
                // setTimeout(() => loadPosts(), 100); // Small delay to ensure DOM is ready
            }
    
            isLoading = false;
        } catch (error) {
            errorMessage.textContent = error.message;
            isLoading = false;
        }
    }
    
    // Function to render posts
    async function renderPosts(postsData) {
      for (const post of postsData) {
        if (document.querySelector(`.post[data-post-id="${post.id}"]`)) continue;
    
        // Await the profile picture for the post author
        const profilePictureHTML = await getCommentAuthorPicture(post.authorId, post.authorName);
    
        // Process post content for @username tags
        let processedContent = post.content;
        
        // Get the current user's reaction for this post
        const userReaction = post.reactions && post.reactions[auth.currentUser.uid];
        const likeClass = userReaction && userReaction.type === 'like' ? 'selected' : '';
        const loveClass = userReaction && userReaction.type === 'love' ? 'selected' : '';
        const laughClass = userReaction && userReaction.type === 'laugh' ? 'selected' : '';
    
        const reactions = post.reactions || {};
        let likeCount = 0, loveCount = 0, laughCount = 0;
        Object.values(reactions).forEach(reaction => {
          if (reaction.type === 'like') likeCount++;
          if (reaction.type === 'love') loveCount++;
          if (reaction.type === 'laugh') laughCount++;
        });
    
        const isAuthor = auth.currentUser && auth.currentUser.uid === post.authorId;
        const likeCountHTML = isAuthor ? `<span class="reaction-count">${likeCount}</span>` : '';
        const loveCountHTML = isAuthor ? `<span class="reaction-count">${loveCount}</span>` : '';
        const laughCountHTML = isAuthor ? `<span class="reaction-count">${laughCount}</span>` : '';
        let mediaHTML = '';
        if (post.photoURL) {
          const orientation = post.mediaOrientation || 'horizontal';
          mediaHTML = `
            <div class="media-container media-${orientation}">
              <img src="${post.photoURL}" class="post-media">
            </div>
          `;
        } else if (post.videoURL) {
          const orientation = post.mediaOrientation || 'horizontal';
          mediaHTML = `
            <div class="media-container media-${orientation}">
              <video controls class="post-media" playsinline webkit-playsinline>
                <source src="${post.videoURL}" type="video/mp4">
              </video>
            </div>
          `;
        }
    
        // Only show the "See comments" button if CommentsVisible is true
        const seeCommentsButtonHTML = `
          <button class="see-comments-button" data-post-id="${post.id}" style="${post.CommentsVisible ? '' : 'display: none;'}">See comments</button>
        `;
    
        let postHTML = `
          <div class="post" data-post-id="${post.id}" data-author-id="${post.authorId}">
            <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
              <div style="display: flex; align-items: center;">
                ${profilePictureHTML}
                <h4 style="margin: 0;">${post.authorName}</h4>
              </div>
              <div style="display: flex; align-items: center;">
                <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp)}</span>
                ${isAuthor ? `<button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>` : ''}
              </div>
            </div>
            <p>${processedContent}</p>
            ${mediaHTML}
            <div class="reactions">
              <button class="reaction-button ${likeClass}" data-post-id="${post.id}" data-reaction="like">üëç${likeCountHTML}</button>
              <button class="reaction-button ${loveClass}" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è${loveCountHTML}</button>
              <button class="reaction-button ${laughClass}" data-post-id="${post.id}" data-reaction="laugh">üòÇ${laughCountHTML}</button>
            </div>
            <div class="comments-section">
              <div class="comment-form">
                <div
                  class="comment-input"
                  contenteditable="true"
                  data-placeholder="Write a comment..."
                  data-post-id="${post.id}"
                ></div>
                <button class="comment-button" data-post-id="${post.id}">Post</button>
              </div>
              ${seeCommentsButtonHTML}
              <div class="comments-loading" id="comments-loading-${post.id}">
                <div class="spinner"></div>
              </div>
              <div class="comments-list" id="comments-${post.id}" data-loaded="false"></div>
            </div>
          </div>
        `;
    
        // In your renderPosts function, check if the post is already rendered
        if (document.querySelector(`.post[data-post-id="${post.id}"]`)) {
          continue; // Skip if already rendered
        }
        feed.insertAdjacentHTML('beforeend', postHTML);
      }
      setupIntersectionObserver();
    }
    
    // Call loadPosts initially to load the first batch
    loadPosts();

    function getInitialsFallback(name) {
      const firstLetter = name.charAt(0).toUpperCase();
      const pastelColors = ['#FFD1DC', '#FFE4B5', '#B5EAD7', '#C7CEEA', '#E2F0CB', '#FFB7B2'];
      const colorIndex = name.charCodeAt(0) % pastelColors.length;
      const backgroundColor = pastelColors[colorIndex];
      return `
        <div style="
          width: 40px;
          height: 40px;
          border-radius: 15%;
          background-color: ${backgroundColor};
          display: flex;
          align-items: center;
          justify-content: center;
          color: #333;
          font-weight: bold;
          font-size: 20px;
          margin-right: 10px;
        ">
          ${firstLetter}
        </div>
      `;
    }

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('reaction-button')) {
        const button = e.target;
        const postId = button.getAttribute('data-post-id');
        const reaction = button.getAttribute('data-reaction');
        const user = auth.currentUser;
        if (!user) return;
    
        // Get the post element and its authorId
        const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
        const postAuthorId = postElement.getAttribute('data-author-id');
    
        // If the post is yours, show the popup and return
        if (postAuthorId === user.uid) {
          const popup = document.getElementById('reaction-popup');
          const reactionList = document.getElementById('reaction-list');
    
          // Fetch the post data to get reactions
          db.collection('posts').doc(postId).get().then((doc) => {
            if (!doc.exists) {
              console.error("Post does not exist!");
              return;
            }
    
            const post = doc.data();
            const reactions = post.reactions || {};
    
            // Clear the reaction list
            reactionList.innerHTML = '';
    
            if (Object.keys(reactions).length === 0) {
              reactionList.innerHTML = '<p>No reactions to your post yet :(</p>';
            } else {
              // Group reactions by type
              const reactionTypes = {
                like: { icon: 'üëç', users: [] },
                love: { icon: '‚ù§Ô∏è', users: [] },
                laugh: { icon: 'üòÇ', users: [] }
              };
    
              // Populate reactionTypes with usernames
              Object.entries(reactions).forEach(([userId, reactionData]) => {
                if (reactionTypes[reactionData.type]) {
                  reactionTypes[reactionData.type].users.push({
                    userId,
                    username: reactionData.username || 'Unknown User'
                  });
                }
              });
    
              // Display reactions
              for (const [type, data] of Object.entries(reactionTypes)) {
                if (data.users.length > 0) {
                  data.users.forEach(user => {
                    const reactionItem = document.createElement('div');
                    reactionItem.className = 'reaction-item';
                    reactionItem.innerHTML = `
                      <span class="reaction-icon">${data.icon}</span>
                      <span class="reaction-username">${user.username}</span>
                    `;
                    reactionList.appendChild(reactionItem);
                  });
                }
              }
            }
          });
    
          popup.style.display = 'block';
          return;
        }
    
        // Optimistic UI update: Assume success
        const postRef = db.collection('posts').doc(postId);
        const wasSelected = button.classList.contains('selected');
    
        // Toggle the selected class
        const likeButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="like"]`);
        const loveButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="love"]`);
        const laughButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="laugh"]`);
    
        // Reset all buttons
        if (likeButton) likeButton.classList.remove('selected');
        if (loveButton) loveButton.classList.remove('selected');
        if (laughButton) laughButton.classList.remove('selected');
    
        // Select the clicked button (unless it was already selected)
        if (!wasSelected) {
          button.classList.add('selected');
        }
    
        // Fetch the post data first
        db.collection('posts').doc(postId).get().then((doc) => {
          if (!doc.exists) {
            console.error("Post does not exist!");
            return;
          }
          const post = doc.data();
    
          // Only update counts for the author's posts
          if (post.authorId === user.uid) {
            const reactions = post.reactions || {};
            let likeCount = 0, loveCount = 0, laughCount = 0;
            Object.values(reactions).forEach(r => {
              if (r.type === 'like') likeCount++;
              if (r.type === 'love') loveCount++;
              if (r.type === 'laugh') laughCount++;
            });
    
            const prevReaction = reactions[user.uid];
            if (prevReaction) {
              if (prevReaction.type === 'like') likeCount--;
              if (prevReaction.type === 'love') loveCount--;
              if (prevReaction.type === 'laugh') laughCount--;
            }
    
            if (!wasSelected) {
              if (reaction === 'like') likeCount++;
              if (reaction === 'love') loveCount++;
              if (reaction === 'laugh') laughCount++;
            }
    
            const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
            const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
            const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
    
            if (likeCountEl) likeCountEl.textContent = likeCount;
            if (loveCountEl) loveCountEl.textContent = loveCount;
            if (laughCountEl) laughCountEl.textContent = laughCount;
          }
    
          // Perform the Firestore transaction
          db.runTransaction((transaction) => {
            return transaction.get(postRef).then((doc) => {
              if (!doc.exists) throw "Post does not exist!";
              const postData = doc.data();
              const reactions = postData.reactions || {};
              const userReaction = reactions[user.uid];
          
              if (userReaction && userReaction.type === reaction) {
                delete reactions[user.uid];
              } else {
                reactions[user.uid] = {
                  type: reaction,
                  timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                  username: user.displayName || "Unknown User"
                };
              }
          
              transaction.update(postRef, { reactions });
              return post;
            });
          }).then((post) => {
            // Only add a notification if the reactor is not the author
            if (post.authorId !== user.uid) {
              // Delete old reaction notifications first
              deleteOldReactionNotifications(
                post.authorId, // Author of the post
                postId,
                user.uid // Current user (reactor)
              ).then(() => {
                // Add the new reaction notification
                addReactionNotification(
                  post.authorId, // Author of the post
                  postId,
                  user.uid, // Current user (reactor)
                  user.displayName || "Unknown User",
                  reaction,
                  firebase.firestore.FieldValue.serverTimestamp()
                );
              });
            }
          }).catch((error) => {
            console.error("Transaction failed: ", error);
            // Revert UI on failure
            if (likeButton) likeButton.classList.remove('selected');
            if (loveButton) loveButton.classList.remove('selected');
            if (laughButton) laughButton.classList.remove('selected');
            if (!wasSelected) {
              if (reaction === 'like' && likeButton) likeButton.classList.add('selected');
              if (reaction === 'love' && loveButton) loveButton.classList.add('selected');
              if (reaction === 'laugh' && laughButton) laughButton.classList.add('selected');
            }
            // Revert count for author
            if (post.authorId === user.uid) {
              db.collection('posts').doc(postId).get().then((doc) => {
                if (doc.exists) {
                  const post = doc.data();
                  const reactions = post.reactions || {};
                  let likeCount = 0, loveCount = 0, laughCount = 0;
                  Object.values(reactions).forEach(r => {
                    if (r.type === 'like') likeCount++;
                    if (r.type === 'love') loveCount++;
                    if (r.type === 'laugh') laughCount++;
                  });
                  const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
                  const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
                  const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
                  if (likeCountEl) likeCountEl.textContent = likeCount;
                  if (loveCountEl) loveCountEl.textContent = loveCount;
                  if (laughCountEl) laughCountEl.textContent = laughCount;
                }
              });
            }
          });
        });
      }

      // Close popup with animation
      document.getElementById('close-reaction-popup').addEventListener('click', () => {
        const popup = document.getElementById('reaction-popup');
        popup.style.animation = 'slideDown 0.3s ease-out forwards';
        setTimeout(() => {
          popup.style.display = 'none';
          popup.style.animation = '';
        }, 300);
      });
    });

    document.getElementById('reaction-popup').addEventListener('click', (e) => {
      if (e.target === e.currentTarget) {
        e.currentTarget.style.display = 'none';
      }
    });

    // Add event listener for comment buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const content = commentInput.innerHTML.trim(); // Use innerHTML instead of textContent
        if (content && content !== '<br>') {
          addComment(postId, content);
          commentInput.innerHTML = ''; // Clear the contenteditable div
          // Automatically show the comments section after posting
          const commentsList = document.getElementById(`comments-${postId}`);
          const seeCommentsButton = document.querySelector(`.see-comments-button[data-post-id="${postId}"]`);
          if (seeCommentsButton) {
            seeCommentsButton.textContent = 'Hide comments';
            commentsList.classList.add('visible');
            loadComments(postId); // Load comments here
          }
        }
      }
    });

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('see-comments-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentsList = document.getElementById(`comments-${postId}`);
        const commentsLoading = document.getElementById(`comments-loading-${postId}`);
        const button = e.target;
    
        // Toggle visibility
        if (commentsList.classList.contains('visible')) {
          commentsList.classList.remove('visible');
          button.textContent = 'See comments';
        } else {
          commentsList.classList.add('visible');
          button.textContent = 'Hide comments';
    
          // Check if comments are already loaded
          const isLoaded = commentsList.getAttribute('data-loaded') === 'true';
          if (!isLoaded) {
            commentsLoading.style.display = 'block';
            loadComments(postId);
          }
        }
      }
    });

    // respond to comment
    document.addEventListener('click', async (e) => { // <-- Add 'async' here
      if (e.target.classList.contains('respond-button')) {
        const authorName = e.target.getAttribute('data-author-name');
        const commentContentDiv = e.target.closest('.comment-content');
        const postId = commentContentDiv.closest('.comments-section').querySelector('.comment-input').getAttribute('data-post-id');
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
    
        // Get the UID of the author being responded to
        const commentElement = e.target.closest('.comment');
        const commentAuthorName = commentElement.querySelector('.comment-author-name').textContent;
        const commentAuthorUid = await getUidByUsername(commentAuthorName); // Now 'await' works
    
        // Insert @AuthorName into the comment input as a tag-validated span WITH data-uid
        const atMention = `@${authorName}`;
        const tagSpan = `<span class="tag-validated" contenteditable="false" data-uid="${commentAuthorUid}">${atMention}</span> `;
        commentInput.focus();
    
        // Insert the tag span
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        range.deleteContents();
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = tagSpan;
        const tagNode = tempDiv.firstChild;
        range.insertNode(tagNode);
    
        // Move cursor to the end of the tag
        range.setStartAfter(tagNode);
        range.collapse(true);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    });
    
    // Function to add a comment to Firestore
    async function addComment(postId, content) {
      const user = auth.currentUser;
      if (!user) return;
    
      const taggedUserUids = extractTaggedUserUids(content);
    
      if (taggedUserUids.length > 0) {
        // Get mutual friends for each tagged user
        const mutualFriendUids = await getMutualFriendUidsForComment(user.uid, taggedUserUids);
    
        // Add the comment to Firestore with taggedUserUids
        const comment = {
          authorId: user.uid,
          authorName: user.displayName || "Unknown User",
          content: content,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          taggedUserUids: taggedUserUids,
        };
    
        try {
          const docRef = await db.collection('posts').doc(postId).collection('comments').add(comment);
    
          // Fetch the post to get the author's UID
          const postDoc = await db.collection('posts').doc(postId).get();
          if (postDoc.exists) {
            const post = postDoc.data();
            // Only add a notification if the commenter is not the author
            if (post.authorId !== user.uid) {
              await addCommentNotification(
                post.authorId, // Author of the post
                postId,
                user.uid, // Current user (commenter)
                user.displayName || "Unknown User",
                content,
                firebase.firestore.FieldValue.serverTimestamp()
              );
            }
          }
    
          // Add tag notifications for each tagged user
          for (const taggedUid of taggedUserUids) {
            await addCommentTagNotification(
              taggedUid, // Tagged user's UID
              postId, // Post ID
              user.uid, // Current user's UID (commenter)
              user.displayName || "Unknown User", // Current user's name
              firebase.firestore.FieldValue.serverTimestamp()
            );
          }
    
          // Update the CommentsVisible flag for mutual friends
          await updateCommentsVisibleForComment(postId, user.uid, taggedUserUids, mutualFriendUids);
    
          // Force the "See comments" button to appear and open the comments section
          const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
          if (postElement) {
            const seeCommentsButton = postElement.querySelector('.see-comments-button');
            const commentsList = postElement.querySelector('.comments-list');
            if (seeCommentsButton) {
              seeCommentsButton.textContent = 'Hide comments';
              seeCommentsButton.style.display = 'block';
            }
            if (commentsList) {
              commentsList.classList.add('visible');
              loadComments(postId); // Load comments here
            }
          }
        } catch (error) {
          console.error("Error adding comment: ", error);
        }
      } else {
        // No tagged users, add comment normally
        const comment = {
          authorId: user.uid,
          authorName: user.displayName || "Unknown User",
          content: content,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
        };
    
        try {
          const docRef = await db.collection('posts').doc(postId).collection('comments').add(comment);
    
          // Fetch the post to get the author's UID
          const postDoc = await db.collection('posts').doc(postId).get();
          if (postDoc.exists) {
            const post = postDoc.data();
            // Only add a notification if the commenter is not the author
            if (post.authorId !== user.uid) {
              await addCommentNotification(
                post.authorId, // Author of the post
                postId,
                user.uid, // Current user (commenter)
                user.displayName || "Unknown User",
                content,
                firebase.firestore.FieldValue.serverTimestamp()
              );
            }
          }
    
          // Update the CommentsVisible flag for all friends
          await updateCommentsVisibleForPost(postId, user.uid);
    
          // Force the "See comments" button to appear and open the comments section
          const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
          if (postElement) {
            const seeCommentsButton = postElement.querySelector('.see-comments-button');
            const commentsList = postElement.querySelector('.comments-list');
            if (seeCommentsButton) {
              seeCommentsButton.textContent = 'Hide comments';
              seeCommentsButton.style.display = 'block';
            }
            if (commentsList) {
              commentsList.classList.add('visible');
              loadComments(postId); // Load comments here
            }
          }
        } catch (error) {
          console.error("Error adding comment: ", error);
        }
      }
    }

    // Function to load comments for a post
    function loadComments(postId) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Show loading indicator
      const commentsLoading = document.getElementById(`comments-loading-${postId}`);
      commentsLoading.style.display = 'block';
    
      // Get the current user's friends (including themselves)
      db.collection('friends').doc(user.uid).get()
        .then((friendsDoc) => {
          const friends = friendsDoc.data()?.friends || [];
          const friendIds = friends.map(friend => friend.uid);
          friendIds.push(user.uid); // Include the current user
    
          // Fetch all comments for the post
          db.collection('posts').doc(postId).collection('comments')
            .orderBy('timestamp', 'asc')
            .get()
            .then((querySnapshot) => {
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.innerHTML = '';
              const commentPromises = [];
    
              querySnapshot.forEach((doc) => {
                const comment = doc.data();
                const taggedUserUids = comment.taggedUserUids || [];
    
                // Always show comments from the current user
                if (comment.authorId === user.uid) {
                  const promise = getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                    const commentHTML = `
                      <div class="comment">
                        <div class="comment-author-picture">
                          ${profilePictureHTML}
                        </div>
                        <div class="comment-content">
                          <div class="comment-author-name">${comment.authorName}</div>
                          <div>${comment.content}</div>
                          <button class="respond-button" data-author-name="${comment.authorName}">Respond</button>
                        </div>
                      </div>
                    `;
                    commentsList.innerHTML += commentHTML;
                  });
                  commentPromises.push(promise);
                }
                // For comments with tagged users, check mutual friendship
                else if (taggedUserUids.length > 0) {
                  // Check if the current user is one of the tagged users
                  if (taggedUserUids.includes(user.uid)) {
                    // Always show the comment if the current user is tagged
                    getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                      const commentHTML = `
                        <div class="comment">
                          <div class="comment-author-picture">
                            ${profilePictureHTML}
                          </div>
                          <div class="comment-content">
                            <div class="comment-author-name">${comment.authorName}</div>
                            <div>${comment.content}</div>
                            <button class="respond-button" data-author-name="${comment.authorName}">Respond</button>
                          </div>
                        </div>
                      `;
                      commentsList.innerHTML += commentHTML;
                    });
                  } else {
                    // Otherwise, check if the current user is a mutual friend
                    isMutualFriendForComment(user.uid, comment.authorId, taggedUserUids)
                      .then((isMutualFriend) => {
                        if (isMutualFriend) {
                          getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                            const commentHTML = `
                              <div class="comment">
                                <div class="comment-author-picture">
                                  ${profilePictureHTML}
                                </div>
                                <div class="comment-content">
                                  <div class="comment-author-name">${comment.authorName}</div>
                                  <div>${comment.content}</div>
                                  <button class="respond-button" data-author-name="${comment.authorName}">Respond</button>
                                </div>
                              </div>
                            `;
                            commentsList.innerHTML += commentHTML;
                          });
                        }
                      });
                  }
                }
                // For comments without tagged users, show if the commenter is a friend
                else if (friendIds.includes(comment.authorId)) {
                  const promise = getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                    const commentHTML = `
                      <div class="comment">
                        <div class="comment-author-picture">
                          ${profilePictureHTML}
                        </div>
                        <div class="comment-content">
                          <div class="comment-author-name">${comment.authorName}</div>
                          <div>${comment.content}</div>
                          <button class="respond-button" data-author-name="${comment.authorName}">Respond</button>
                        </div>
                      </div>
                    `;
                    commentsList.innerHTML += commentHTML;
                  });
                  commentPromises.push(promise);
                }
              });
    
              return Promise.all(commentPromises);
            })
            .catch((error) => {
              console.error("Error loading comments: ", error);
            })
            .finally(() => {
              // Hide loading indicator and mark comments as loaded
              commentsLoading.style.display = 'none';
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.setAttribute('data-loaded', 'true');
            });
        })
        .catch((error) => {
          console.error("Error fetching friends: ", error);
          // Hide loading indicator
          commentsLoading.style.display = 'none';
        });
    }
    
    // Function to get the author's profile picture for comments
    function getCommentAuthorPicture(authorId, authorName) {
      return db.collection('users').doc(authorId).get().then((userDoc) => {
        if (userDoc.exists) {
          const userData = userDoc.data();
          const profilePictureURL = userData.profilePictureURL;
          if (profilePictureURL) {
            return `<img src="${profilePictureURL}" alt="Profile Picture" class="comment-author-picture">`;
          } else {
            // Use displayName for the initials fallback
            return getInitialsFallback(authorName || "Unknown User");
          }
        } else {
          return getInitialsFallback("Unknown User");
        }
      }).catch(() => {
        return getInitialsFallback("Unknown User");
      });
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString(); // You can customize the format as needed
    }

    // Function to log the current user's friends and their posts to the console
    async function logUserFriendsWithPosts(userId) {
        let friendIds = [];
        try {
            // Log the current user and their posts
            const userPostsSnapshot = await db.collection('posts')
                .where('authorId', '==', userId)
                .orderBy('timestamp', 'desc')
                .get();
    
            const userPosts = userPostsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
    
            console.log(`- User: ${auth.currentUser.displayName || "Current User"}`);
            if (userPosts.length > 0) {
                console.log("  Posts:");
                userPosts.forEach(post => {
                    console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                });
            } else {
                console.log("  No posts found.");
            }
    
            // Log the user's friends and their posts
            const friendsDoc = await db.collection('friends').doc(userId).get();
            if (friendsDoc.exists) {
                friendIds = friendsDoc.data()?.friends.map(friend => friend.uid) || [];
                for (const friend of friendIds) {
                    const postsSnapshot = await db.collection('posts')
                        .where('authorId', '==', friend)
                        .orderBy('timestamp', 'desc')
                        .get();
    
                    const posts = postsSnapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
    
                    console.log(`- Friend: ${friend}`);
                    if (posts.length > 0) {
                        console.log("  Posts:");
                        posts.forEach(post => {
                            console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                        });
                    } else {
                        console.log("  No posts found.");
                    }
                }
            } else {
                console.log("No friends document found for this user.");
            }
        } catch (error) {
            console.error("Error fetching user/friends or posts:", error);
        }
        return friendIds; // Return the list of friend IDs
    }

    // Throttle function to limit how often the scroll event fires
    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function() {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                    if ((Date.now() - lastRan) >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }

    async function getUidByUsername(username) {
      const user = auth.currentUser;
      if (!user) return null;
    
      // Fetch the user's friends
      const friendsDoc = await db.collection('friends').doc(user.uid).get();
      if (!friendsDoc.exists) return null;
    
      const friends = friendsDoc.data()?.friends || [];
      const friend = friends.find(f => f.name === username);
      return friend ? friend.uid : null;
    }
    
    // Function to check if the user has scrolled to the bottom
    function isAtBottom() {
        return (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200;
    }

    // Replace your setupIntersectionObserver with this:
    function setupIntersectionObserver() {
      const options = { root: null, rootMargin: '200px', threshold: 0.1 };
      const observer = new IntersectionObserver(
        throttle((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.target === feed.lastElementChild) {
              loadPosts();
            }
          });
        }, 500),
        options
      );
      const posts = document.querySelectorAll('.post');
      if (posts.length > 0) observer.observe(posts[posts.length - 1]);
    }

    function extractTaggedUserUids(content) {
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const tags = tempDiv.querySelectorAll('.tag-validated');
      const uids = [];
      tags.forEach(tag => {
        const uid = tag.dataset.uid;
        if (uid) uids.push(uid);
      });
      return uids;
    }

    async function getMutualFriendUids(userUid1, userUid2) {
      const friends1 = await getFriendUidsForUser(userUid1);
      const friends2 = await getFriendUidsForUser(userUid2);
      return friends1.filter(uid => friends2.includes(uid));
    }

    document.querySelectorAll('.orientation-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.orientation-button').forEach(b => b.classList.remove('selected'));
        button.classList.add('selected');
      });
    });

    const getSelectedOrientation = () => {
      const selectedButton = document.querySelector('.orientation-button.selected');
      return selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    };

    // Add this near your other event listeners
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-post-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const confirmDelete = confirm('Are you sure you want to delete this post?');
        if (confirmDelete) {
          deletePost(postId);
        }
      }
    });
    
    // Define the deletePost function
    async function deletePost(postId) {
      // Show the overlay
      document.getElementById('upload-overlay').style.display = 'flex';
    
      try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) {
          console.error('Post does not exist');
          return;
        }
    
        const postData = postDoc.data();
        const storage = firebase.storage();
        const authorId = postData.authorId;
    
        // Delete media from Storage if it exists
        if (postData.photoURL) {
          const photoRef = storage.refFromURL(postData.photoURL);
          await photoRef.delete();
        }
        if (postData.videoURL) {
          const videoRef = storage.refFromURL(postData.videoURL);
          await videoRef.delete();
        }
    
        // Delete the post document
        await postRef.delete();
    
        // Fetch the list of friends for the author
        const friendUids = await getFriendUidsForUser(authorId);
    
        // Add the author's UID to the list
        friendUids.push(authorId);
    
        // Delete the post from the feed sub-collections of the author and all friends
        const batch = db.batch();
        for (const uid of friendUids) {
          const feedRef = db.collection(`users/${uid}/feed`).doc(postId);
          batch.delete(feedRef);
        }
        await batch.commit();
    
        // Remove the post from the UI
        const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
        if (postElement) {
          postElement.remove();
        }
    
        alert('Post deleted successfully!');
      } catch (error) {
        console.error('Error deleting post:', error);
        alert(translations[userLanguage]["Failed to delete post. Please try again."]);
      } finally {
        // Hide the overlay
        document.getElementById('upload-overlay').style.display = 'none';
      }
    }

    // Fetch and display friends list
    document.getElementById('visibility-button').addEventListener('click', async () => {
      const user = auth.currentUser;
      if (!user) return;
    
      const friendsList = document.getElementById('friends-list');
      friendsList.innerHTML = '<li>Loading...</li>';
    
      try {
        const friendsDoc = await db.collection('friends').doc(user.uid).get();
        if (friendsDoc.exists) {
          const friends = friendsDoc.data()?.friends || [];
          friendsList.innerHTML = '';
    
          // Add "Select All Friends" option
          const selectAllLi = document.createElement('li');
          selectAllLi.id = 'select-all-friends';
          selectAllLi.innerHTML = `
            Select All Friends
            <button id="select-all-toggle" class="friend-toggle active"></button>
          `;
          friendsList.appendChild(selectAllLi);
    
          if (friends.length === 0) {
            friendsList.innerHTML = '<li>No friends found.</li>';
          } else {
            friends.forEach(friend => {
              const li = document.createElement('li');
              li.innerHTML = `
                ${friend.name}
                <button class="friend-toggle active" data-uid="${friend.uid}"></button>
              `;
              friendsList.appendChild(li);
            });
          }
        } else {
          friendsList.innerHTML = '<li>No friends found.</li>';
        }
      } catch (error) {
        friendsList.innerHTML = '<li>Error loading friends.</li>';
        console.error("Error fetching friends:", error);
      }
    
      document.getElementById('visibility-modal').style.display = 'flex';
    });
    
    // Close the modal
    document.getElementById('close-visibility-modal').addEventListener('click', () => {
      const visibilityButton = document.getElementById('visibility-button');
      if (isVisibilityAll) {
        visibilityButton.textContent = 'Visibility: all friends';
      } else {
        visibilityButton.textContent = 'Visibility: limited';
      }
      document.getElementById('visibility-modal').style.display = 'none';
    });

    postMedia.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
            document.getElementById('image-preview-container').style.display = 'none';
            document.getElementById('video-preview-container').style.display = 'none';
            return;
        }

        // Store the original file
        if (file.type.startsWith('image/')) {
            originalImageFile = file;
            lastCropOrientation = 'horizontal'; // Reset to default
        }
    
        // Reset the media input and previews
        document.getElementById('image-preview-container').style.display = 'none';
        document.getElementById('video-preview-container').style.display = 'none';
    
        if (file.type.startsWith('image/')) {
            // Handle image
            const reader = new FileReader();
            reader.onload = (e) => {
                const preview = document.getElementById('image-preview');
                const previewContainer = document.getElementById('image-preview-container');
                preview.src = e.target.result;
                previewContainer.style.display = 'block';
    
                const modal = document.getElementById('image-cropper-modal');
                const cropperImage = document.getElementById('cropper-image');
                cropperImage.src = e.target.result;
                modal.style.display = 'block';
                
                // Reset the orientation button state to default (horizontal)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.classList.remove('selected');
                });
                document.querySelector('.crop-orientation-button[data-orientation="horizontal"]').classList.add('selected');
                
                // Initialize Cropper.js with the correct aspect ratio
                let cropperAspectRatio = 16 / 9; // Default to horizontal
                let cropper = new Cropper(cropperImage, {
                    aspectRatio: cropperAspectRatio,
                    viewMode: 1,
                    dragMode: 'move',
                    guides: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    modal: true,
                });
    
                // Toggle orientation buttons (your existing code)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        const orientation = button.getAttribute('data-orientation');
                        cropperAspectRatio = orientation === 'horizontal' ? 16 / 9 : 3 / 4;
                        cropper.setAspectRatio(cropperAspectRatio);
                    });
                });
    
                // Handle "Done" button (your existing code)
                document.getElementById('crop-done-button').onclick = () => {
                    const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
                    let width, height;
                    if (selectedOrientation === 'horizontal') {
                        width = 1200;
                        height = 675;
                        quality = 0.92;
                        mimeType = 'image/jpeg';
                    } else {
                        width = 1080;
                        height = 1440;
                        quality = 1;
                        mimeType = 'image/png';
                    }
                    const canvas = cropper.getCroppedCanvas({ width, height, fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                    canvas.toBlob(
                      (blob) => {
                        const croppedFile = new File([blob], file.name, { type: 'image/jpeg' });
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(croppedFile);
                        postMedia.files = dataTransfer.files;
                        postMedia.setAttribute('data-orientation', selectedOrientation);
                        postMedia.setAttribute('data-type', 'image');
                
                        // Update the preview with the cropped image
                        const preview = document.getElementById('image-preview');
                        preview.src = URL.createObjectURL(croppedFile);
                        document.getElementById('image-preview-container').style.display = 'block';
                
                        modal.style.display = 'none';
                        cropper.destroy();
                      },
                      'image/jpeg',
                      quality
                    );
                };
    
                // Handle "Cancel" button
                document.getElementById('crop-cancel-button').onclick = () => {
                    modal.style.display = 'none';
                    cropper.destroy();
                    postMedia.value = '';
                    document.getElementById('image-preview-container').style.display = 'none';
                    document.getElementById('video-preview-container').style.display = 'none';
                };
            };
            reader.readAsDataURL(file);
        } else if (file.type.startsWith('video/')) {
            // Handle video preview
            checkVideoDuration(file, (isValid) => {
                if (!isValid) {
                    errorMessage.textContent = translations[userLanguage]["Video must be 10 seconds or shorter."];
                    postMedia.value = '';
                    document.getElementById('video-preview-container').style.display = 'none';
                } else {
                    const videoPreview = document.getElementById('video-preview');
                    const videoPreviewContainer = document.getElementById('video-preview-container');
                    videoPreview.src = URL.createObjectURL(file);
                    videoPreviewContainer.style.display = 'block';
                    postMedia.setAttribute('data-type', 'video');
                    postMedia.setAttribute('data-orientation', 'vertical');
                }
            });
        }
    });

    // Set default visibility button text
    document.getElementById('visibility-button').textContent = 'Visibility: all friends';

    /**
     * Adds a comment tag notification to a user's notifications sub-collection.
     * @param {string} taggedUid - The tagged user's UID.
     * @param {string} postId - The post's ID.
     * @param {string} commenterId - The UID of the user who commented and tagged.
     * @param {string} commenterName - The name of the user who commented and tagged.
     * @param {Date} timestamp - The timestamp of the comment.
     */
    async function addCommentTagNotification(taggedUid, postId, commenterId, commenterName, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${taggedUid}/notifications`);
    
        // Query for existing notifications
        const querySnapshot = await notificationsRef
          .where('type', '==', 'comment_tag')
          .where('postId', '==', postId)
          .where('commenterId', '==', commenterId)
          .get();
    
        if (!querySnapshot.empty) {
          // Update existing notification
          querySnapshot.forEach((doc) => {
            doc.ref.update({
              timestamp,
              message: `${commenterName} tagged you again in a comment.`
            });
          });
        } else {
          // Create new notification
          await notificationsRef.add({
            type: "comment_tag",
            commenterId,
            commenterName,
            postId,
            timestamp,
            message: `${commenterName} tagged you in a comment.`
          });
        }
      } catch (error) {
        console.error("Error adding/updating comment tag notification:", error);
      }
    }
    
    /**
     * Adds a tag notification to a user's notifications sub-collection.
     * @param {string} taggedUid - The tagged user's UID.
     * @param {string} postId - The post's ID.
     * @param {string} taggerId - The UID of the user who tagged.
     * @param {string} taggerName - The name of the user who tagged.
     * @param {Date} timestamp - The timestamp of the tag.
     */
    async function addTagNotification(taggedUid, postId, taggerId, taggerName, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${taggedUid}/notifications`).doc();
        await notificationsRef.set({
          type: "tag",
          taggerId,
          taggerName,
          postId,
          timestamp,
          message: `${taggerName} tagged you in a post.`
        });
      } catch (error) {
        console.error("Error adding tag notification:", error);
      }
    }

    /**
     * Adds a post to a user's feed sub-collection.
     * @param {string} userId - The user's UID.
     * @param {string} postId - The post's ID.
     * @param {Date} timestamp - The post's timestamp.
     */
    async function addPostToUserFeed(userId, postId, timestamp) {
      try {
        const feedRef = db.collection(`users/${userId}/feed`).doc(postId);
        await feedRef.set({
          postId: postId,
          postTimestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding post to user feed:', error);
      }
    }

    /**
     * Fetches the list of friend UIDs for a user.
     * @param {string} userId - The user's UID.
     * @returns {Promise<string[]>} - Array of friend UIDs.
     */
    async function getFriendUidsForUser(userId) {
      try {
        const friendsDoc = await db.collection('friends').doc(userId).get();
        if (friendsDoc.exists) {
          const friends = friendsDoc.data()?.friends || [];
          return friends.map(friend => friend.uid);
        } else {
          return [];
        }
      } catch (error) {
        console.error('Error fetching friends:', error);
        return [];
      }
    }

    /**
     * Adds a notification to a user's notifications sub-collection.
     * @param {string} userId - The user's UID.
     * @param {string} postId - The post's ID.
     * @param {string} reactorId - The UID of the user who reacted.
     * @param {string} reactorName - The name of the user who reacted.
     * @param {string} reaction - The type of reaction (like, love, laugh).
     * @param {Date} timestamp - The timestamp of the reaction.
     */
    async function addReactionNotification(userId, postId, reactorId, reactorName, reaction, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`).doc();
        await notificationsRef.set({
          type: 'reaction',
          reactorId,
          reactorName,
          reaction,
          postId,
          timestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding reaction notification:', error);
      }
    }

    /**
     * Deletes all reaction notifications for a user on a specific post.
     * @param {string} userId - The user's UID (post author).
     * @param {string} postId - The post's ID.
     * @param {string} reactorId - The UID of the user who reacted.
     */
    async function deleteOldReactionNotifications(userId, postId, reactorId) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`);
        const querySnapshot = await notificationsRef
          .where('type', '==', 'reaction')
          .where('postId', '==', postId)
          .where('reactorId', '==', reactorId)
          .get();
    
        const batch = db.batch();
        querySnapshot.forEach((doc) => {
          batch.delete(doc.ref);
        });
        await batch.commit();
      } catch (error) {
        console.error('Error deleting old reaction notifications:', error);
      }
    }

    /**
     * Adds a comment notification to a user's notifications sub-collection.
     * @param {string} userId - The user's UID (post author).
     * @param {string} postId - The post's ID.
     * @param {string} commenterId - The UID of the user who commented.
     * @param {string} commenterName - The name of the user who commented.
     * @param {string} commentContent - The content of the comment.
     * @param {Date} timestamp - The timestamp of the comment.
     */
    async function addCommentNotification(userId, postId, commenterId, commenterName, commentContent, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`).doc();
        await notificationsRef.set({
          type: 'comment',
          reactorId: commenterId,
          reactorName: commenterName,
          commentContent: commentContent,
          postId: postId,
          timestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding comment notification:', error);
      }
    }

    /**
     * Updates the CommentsVisible flag for all users who have the post in their feed and are friends with the commenter.
     * @param {string} postId - The ID of the post.
     * @param {string} commenterId - The UID of the user who commented.
     */
    async function updateCommentsVisibleForPost(postId, commenterId) {
      try {
        // 1. Get the post to find the author
        const postDoc = await db.collection('posts').doc(postId).get();
        if (!postDoc.exists) {
          console.log('Post does not exist.');
          return;
        }
        const post = postDoc.data();
        const authorId = post.authorId;
    
        // 2. Create a batch for updates
        const batch = db.batch();
    
        // 3. Always update the CommentsVisible flag for the post author
        const authorFeedDocRef = db.collection(`users/${authorId}/feed`).doc(postId);
        batch.update(authorFeedDocRef, { CommentsVisible: true });
    
        // 4. Always update the CommentsVisible flag for the commenter
        const commenterFeedDocRef = db.collection(`users/${commenterId}/feed`).doc(postId);
        batch.update(commenterFeedDocRef, { CommentsVisible: true });
    
        // 5. Get the author's friends (including the author)
        const friendsDoc = await db.collection('friends').doc(authorId).get();
        const friends = friendsDoc.exists ? friendsDoc.data()?.friends || [] : [];
        const friendIds = friends.map(friend => friend.uid);
        friendIds.push(authorId); // Include the author
    
        // 6. For each friend, check if they have the post in their feed
        for (const userId of friendIds) {
          if (userId === authorId || userId === commenterId) continue; // Skip author and commenter, already handled
    
          const feedDocRef = db.collection(`users/${userId}/feed`).doc(postId);
          const feedDoc = await feedDocRef.get();
          if (feedDoc.exists) {
            // 7. Check if the commenter is a friend of this user
            const userFriendsDoc = await db.collection('friends').doc(userId).get();
            if (userFriendsDoc.exists) {
              const userFriends = userFriendsDoc.data()?.friends || [];
              const userFriendIds = userFriends.map(friend => friend.uid);
              userFriendIds.push(userId); // Include the user themselves
    
              if (userFriendIds.includes(commenterId)) {
                // 8. Update the CommentsVisible flag to true
                batch.update(feedDocRef, { CommentsVisible: true });
              }
            }
          }
        }
    
        // 9. Commit the batch update
        await batch.commit();
        console.log('Updated CommentsVisible flag for users who have this post in their feed.');
      } catch (error) {
        console.error('Error updating CommentsVisible flag:', error);
      }
    }

    /**
     * Gets mutual friend UIDs for a comment with tagged users.
     * @param {string} commenterUid - The UID of the commenter.
     * @param {string[]} taggedUserUids - Array of tagged user UIDs.
     * @returns {Promise<string[]>} - Array of mutual friend UIDs.
     */
    async function getMutualFriendUidsForComment(commenterUid, taggedUserUids) {
      if (taggedUserUids.length === 0) return [];
    
      let mutualFriendUids = await getMutualFriendUids(commenterUid, taggedUserUids[0]);
    
      for (let i = 1; i < taggedUserUids.length; i++) {
        const mutuals = await getMutualFriendUids(commenterUid, taggedUserUids[i]);
        mutualFriendUids = mutualFriendUids.filter(uid => mutuals.includes(uid));
      }
    
      return mutualFriendUids;
    }
    
    /**
     * Checks if the current user is a mutual friend of the commenter and all tagged users.
     * @param {string} currentUserUid - The UID of the current user.
     * @param {string} commenterUid - The UID of the commenter.
     * @param {string[]} taggedUserUids - Array of tagged user UIDs.
     * @returns {Promise<boolean>} - True if the current user is a mutual friend.
     */
    async function isMutualFriendForComment(currentUserUid, commenterUid, taggedUserUids) {
      if (taggedUserUids.length === 0) return true;
    
      const mutualFriendUids = await getMutualFriendUidsForComment(commenterUid, taggedUserUids);
      return mutualFriendUids.includes(currentUserUid);
    }
    
    /**
     * Updates the CommentsVisible flag for a comment with tagged users.
     * @param {string} postId - The ID of the post.
     * @param {string} commenterId - The UID of the commenter.
     * @param {string[]} taggedUserUids - Array of tagged user UIDs.
     * @param {string[]} mutualFriendUids - Array of mutual friend UIDs.
     */
    async function updateCommentsVisibleForComment(postId, commenterId, taggedUserUids, mutualFriendUids) {
      try {
        const batch = db.batch();
    
        // Update CommentsVisible flag for mutual friends
        for (const uid of mutualFriendUids) {
          const feedDocRef = db.collection(`users/${uid}/feed`).doc(postId);
          batch.update(feedDocRef, { CommentsVisible: true });
        }
    
        // Update CommentsVisible flag for the commenter
        const commenterFeedDocRef = db.collection(`users/${commenterId}/feed`).doc(postId);
        batch.update(commenterFeedDocRef, { CommentsVisible: true });
    
        // Update CommentsVisible flag for each tagged user
        for (const uid of taggedUserUids) {
          const taggedUserFeedDocRef = db.collection(`users/${uid}/feed`).doc(postId);
          batch.update(taggedUserFeedDocRef, { CommentsVisible: true });
        }
    
        await batch.commit();
      } catch (error) {
        console.error('Error updating CommentsVisible flag for comment:', error);
      }
    }

    document.getElementById('image-preview').addEventListener('click', () => {
        if (originalImageFile) {
            const modal = document.getElementById('image-cropper-modal');
            const cropperImage = document.getElementById('cropper-image');
            const reader = new FileReader();
            reader.onload = (e) => {
                cropperImage.src = e.target.result;
                modal.style.display = 'block';
    
                // Get the currently selected orientation button
                const selectedButton = document.querySelector('.crop-orientation-button.selected');
                const currentOrientation = selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    
                // Set the button state to match the current orientation
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.classList.remove('selected');
                    if (button.getAttribute('data-orientation') === currentOrientation) {
                        button.classList.add('selected');
                    }
                });
    
                // Initialize Cropper.js with the current aspect ratio
                let cropperAspectRatio = currentOrientation === 'horizontal' ? 16 / 9 : 3 / 4;
                let cropper = new Cropper(cropperImage, {
                    aspectRatio: cropperAspectRatio,
                    viewMode: 1,
                    dragMode: 'move',
                    guides: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    modal: true,
                });
    
                // Toggle orientation buttons
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        const orientation = button.getAttribute('data-orientation');
                        lastCropOrientation = orientation; // Update the last used orientation
                        cropperAspectRatio = orientation === 'horizontal' ? 16 / 9 : 3 / 4;
                        cropper.setAspectRatio(cropperAspectRatio);
                    });
                });
    
                // Handle "Done" button
                document.getElementById('crop-done-button').onclick = () => {
                    const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
                    let width, height, quality, mimeType;
                    if (selectedOrientation === 'horizontal') {
                        width = 1200;
                        height = 675;
                        quality = 0.92;
                        mimeType = 'image/jpeg';
                    } else {
                        width = 1080;
                        height = 1440;
                        quality = 1;
                        mimeType = 'image/png';
                    }
                    const canvas = cropper.getCroppedCanvas({ width, height, fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                    canvas.toBlob(
                        (blob) => {
                            const croppedFile = new File([blob], 'cropped-image.jpg', { type: mimeType });
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(croppedFile);
                            postMedia.files = dataTransfer.files;
                            postMedia.setAttribute('data-orientation', selectedOrientation);
                            postMedia.setAttribute('data-type', 'image');
    
                            // Update the preview with the cropped image
                            const preview = document.getElementById('image-preview');
                            preview.src = URL.createObjectURL(croppedFile);
                            modal.style.display = 'none';
                            cropper.destroy();
                        },
                        mimeType,
                        quality
                    );
                };
    
                // Handle "Cancel" button
                document.getElementById('crop-cancel-button').onclick = () => {
                    modal.style.display = 'none';
                    cropper.destroy();
                };
            };
            reader.readAsDataURL(originalImageFile);
        }
    });

    function checkVideoDuration(file, callback) {
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.onloadedmetadata = () => {
        window.URL.revokeObjectURL(video.src);
        callback(video.duration <= 10);
      };
      video.src = URL.createObjectURL(file);
    }

    async function postHasComments(postId) {
      const commentsSnapshot = await db.collection('posts').doc(postId).collection('comments').get();
      return !commentsSnapshot.empty;
    }

    // Handle "Select All" and individual friend toggle clicks
    document.getElementById('friends-list').addEventListener('click', (e) => {
      if (e.target.id === 'select-all-toggle') {
        const isActive = e.target.classList.contains('active');
        const friendToggles = document.querySelectorAll('.friend-toggle:not(#select-all-toggle)');
    
        if (isActive) {
          e.target.classList.remove('active');
          friendToggles.forEach(toggle => toggle.classList.remove('active'));
          isVisibilityAll = false;
        } else {
          e.target.classList.add('active');
          friendToggles.forEach(toggle => toggle.classList.add('active'));
          isVisibilityAll = true;
        }
      } else if (e.target.classList.contains('friend-toggle')) {
        e.target.classList.toggle('active');
    
        // If any individual toggle is deselected, deselect "Select All"
        const allToggles = document.querySelectorAll('.friend-toggle:not(#select-all-toggle)');
        const allActive = Array.from(allToggles).every(toggle => toggle.classList.contains('active'));
        const selectAllToggle = document.getElementById('select-all-toggle');
    
        if (allActive) {
          selectAllToggle.classList.add('active');
          isVisibilityAll = true;
        } else {
          selectAllToggle.classList.remove('active');
          isVisibilityAll = false;
        }
      }
    });

    // Load posts when page loads
    window.onload = loadPosts;

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('ServiceWorker registration successful');
            // Force update check
            registration.update();
          })
          .catch((err) => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }

    let userLanguage = "English"; // Define globally
    // Update placeholders
    document.getElementById('post-content').placeholder = translations[userLanguage]["How's life treating ya?"];
    document.querySelectorAll('.comment-input').forEach(input => {
      input.placeholder = translations[userLanguage]["Write a comment..."];
    });

    // Translations dictionary
    const translations = {
      English: {
        "Create a Post": "Create a Post",
        "How's life treating ya?": "How's life treating ya?",
        "Photo/Video": "Photo/Video",
        "Post": "Post",
        "Adjust Image": "Adjust Image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Done",
        "Cancel": "Cancel",
        "Video must be 10 seconds or shorter.": "Video must be 10 seconds or shorter.",
        "Post created!": "Post created!",
        "Are you sure you want to delete this post?": "Are you sure you want to delete this post?",
        "Post deleted successfully!": "Post deleted successfully!",
        "Failed to delete post. Please try again.": "Failed to delete post. Please try again.",
        "Your Feed": "Your Feed",
        "Feed": "Feed",
        "Profile": "Profile",
        "Post content cannot be empty.": "Post content cannot be empty.",
        "Write a comment...": "Write a comment...",
        "Transaction failed: ": "Transaction failed: ",
      },
      French: {
        "Create a Post": "Cr√©er une publication",
        "How's life treating ya?": "Comment √ßa va ?",
        "Photo/Video": "Photo/Vid√©o",
        "Post": "Publier",
        "Adjust Image": "Ajuster l'image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Termin√©",
        "Cancel": "Annuler",
        "Video must be 10 seconds or shorter.": "La vid√©o doit durer 10 secondes ou moins.",
        "Post created!": "Publication cr√©√©e !",
        "Are you sure you want to delete this post?": "√ätes-vous s√ªr de vouloir supprimer cette publication ?",
        "Post deleted successfully!": "Publication supprim√©e avec succ√®s !",
        "Failed to delete post. Please try again.": "√âchec de la suppression de la publication. Veuillez r√©essayer.",
        "Your Feed": "Votre fil d'actualit√©",
        "Feed": "Fil d'actualit√©",
        "Profile": "Profil",
        "Post content cannot be empty.": "Le contenu de la publication ne peut pas √™tre vide.",
        "Write a comment...": "√âcrivez un commentaire...",
        "Transaction failed: ": "√âchec de la transaction : ",
      },
      Korean: {
        "Create a Post": "Í≤åÏãúÎ¨º ÏûëÏÑ±",
        "How's life treating ya?": "ÏöîÏ¶ò Ïñ¥ÎñªÍ≤å ÏßÄÎÇ¥ÏÑ∏Ïöî?",
        "Photo/Video": "ÏÇ¨ÏßÑ/ÎπÑÎîîÏò§",
        "Post": "Í≤åÏãú",
        "Adjust Image": "Ïù¥ÎØ∏ÏßÄ Ï°∞Ï†ï",
        "Horizontal": "Í∞ÄÎ°ú",
        "Vertical": "ÏÑ∏Î°ú",
        "Done": "ÏôÑÎ£å",
        "Cancel": "Ï∑®ÏÜå",
        "Video must be 10 seconds or shorter.": "ÎπÑÎîîÏò§Îäî 10Ï¥à Ïù¥ÌïòÏó¨Ïïº Ìï©ÎãàÎã§.",
        "Post created!": "Í≤åÏãúÎ¨ºÏù¥ ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§!",
        "Are you sure you want to delete this post?": "Ïù¥ Í≤åÏãúÎ¨ºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        "Post deleted successfully!": "Í≤åÏãúÎ¨ºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!",
        "Failed to delete post. Please try again.": "Í≤åÏãúÎ¨º ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
        "Your Feed": "ÌîºÎìú",
        "Feed": "ÌîºÎìú",
        "Profile": "ÌîÑÎ°úÌïÑ",
        "Post content cannot be empty.": "Í≤åÏãúÎ¨º ÎÇ¥Ïö©Ïù¥ ÎπÑÏñ¥ ÏûàÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        "Write a comment...": "ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±ÌïòÏÑ∏Ïöî...",
        "Transaction failed: ": "Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®: ",
      }
    };
    
    // Function to update the page language
    function updatePageLanguage(language) {
      const lang = translations[language] || translations["English"];
      document.querySelectorAll("[data-i18n]").forEach((element) => {
        const key = element.getAttribute("data-i18n");
        if (lang[key]) {
          element.textContent = lang[key];
        }
      });
    }

  </script>
</body>
</html>
