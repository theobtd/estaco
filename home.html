<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Estaco</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
  <style>
    :root {
      --estaco-primary: #8B8E6F; /* Light olive */
      --estaco-primary-light: #A7A98C; /* Lighter olive for hover states */
      --estaco-secondary: #E2725B; /* Soft terracotta */
      --estaco-accent: #FFD700; /* Warm yellow (for buttons, accents) */
      --estaco-background: #FFFFFF;
      --estaco-surface: #F9F9F9;
      --estaco-text: #333333;
      --estaco-text-light: #666666;
      --estaco-border: #E0E0E0;
      --estaco-error: #F44336;
      --estaco-success: #4CAF50;
    }

    body {
        font-family: Arial, sans-serif;
        max-width: 100%; /* Remove fixed max-width */
        margin: 0;
        padding: 0; /* Remove padding to allow full-width media */
        padding-bottom: 60px;
        padding-top: 60px;
    }
    #post-form {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background-color: #ffffff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    #post-photo {
      width: 95%;
      padding: 8px;
      margin: 5px 0;
    }
    #post-content {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      resize: none;
      font-size: 15px;
      box-sizing: border-box;
    }
    input, textarea {
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    html, body {
      overflow-x: hidden;
      width: 100%;
    }
    #post-media-label {
      display: inline-flex;
      align-items: center;
      padding: 10px 15px;
      background: var(--estaco-surface);
      color: var(--estaco-text);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
      transition: background-color 0.2s;
    }
    #post-button {
      padding: 10px 20px;
      background-color: var(--estaco-primary); /* Light olive */
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .post-form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    #feed {
      margin-top: 20px;
      width: 100%;
    }
    .post {
      padding: 10px;
      border: 1px solid var(--estaco-border);
      border-radius: 5px;
      margin-bottom: 10px;
      margin-left: 0;
      margin-right: 0;
      background: var(--estaco-background);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    #error-message {
      color: red;
    }
    .post-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .post-author-picture {
      width: 40px;
      height: 40px;
      border-radius: 15%;
      margin-right: 10px;
    }
    .reactions {
      margin-top: 10px;
    }
    .reaction-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-right: 5px;
    }
    .reaction-count {
      font-size: 12px;
      margin-left: 3px;
      color: #666;
    }
    .reaction-button.selected {
      background-color: var(--estaco-primary);
      color: white;
      border-radius: 4px;
      padding: 2px 4px;
    }
    .comments-section {
      margin-top: 10px;
      border-top: 1px solid var(--estaco-border);
      padding-top: 10px;
    }
    .comment-form {
      display: flex;
      margin-bottom: 10px;
    }
    .comment-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .comment-button {
      padding: 8px 12px;
      background: var(--estaco-accent);
      border: none;
      border-radius: 4px;
      margin-left: 5px;
      cursor: pointer;
    }
    .comment {
      display: flex;
      margin-bottom: 8px;
      align-items: flex-start;
    }
    .comment-author-picture {
      width: 30px;
      height: 30px;
      border-radius: 10%; /* Adjust this value to control the roundness */
      margin-right: 8px;
    }
    .comment-content {
      background: var(--estaco-surface);
      padding: 8px 12px;
      border-radius: 8px;
      flex: 1;
    }
    .comment-author-name {
      font-weight: bold;
      margin-bottom: 2px;
    }
    .post-timestamp {
      text-align: right;
      font-size: 12px;
      color: var(--estaco-text-light);
      margin-top: -15px; /* Adjust as needed to move it closer to the header */
    }
    .media-container {
      position: relative;
      margin-top: 10px;
      overflow: hidden;
      background-color: var(--estaco-surface);
    }
    .media-horizontal,
    .media-vertical {
      width: 100%; /* Full width of the parent container */
      height: auto; /* Let height be calculated based on aspect ratio */
      position: relative;
      overflow: hidden;
      background-color: transparent; /* Remove grey background */
      margin: 0; /* Remove any default margins */
    }
    
    /* Horizontal media: 4:3 aspect ratio */
    .media-horizontal {
        aspect-ratio: 16 / 9;
    }
    
    /* Vertical media: 3:4 aspect ratio */
    .media-vertical {
        aspect-ratio: 3 / 4;
    }
    
    /* Media inside the container */
    .media-container img,
    .media-container video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* Use cover to fill the container */
    }
    .orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .orientation-button.selected {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }
    .delete-post-button {
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .crop-orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .crop-orientation-button.selected {
      background: var(--estaco-primary);
      color: white;
      border-color: var(--estaco-primary);
    }
    #image-preview-container {
        display: none;
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f9f9f9;
    }
    #image-preview {
        max-width: 100%;
        max-height: 200px;
        border-radius: 4px;
        display: block;
        margin: 0 auto;
    }
    #post-media {
        display: none;
    }
    .video-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
    }
    
    .custom-play-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .custom-play-button.hidden {
        display: none;
    }

    #bottom-nav-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
      background-color: white;
      border-top: 1px solid #e0e0e0;
      padding: 8px 0;
      z-index: 100;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
    }
    
    .nav-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      color: #333;
      font-size: 12px;
    }
    
    .nav-button .icon {
      font-size: 24px;
      margin-bottom: 4px;
    }
    
    .nav-button .label {
      font-size: 12px;
    }

    #top-nav-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: white;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 0;
      z-index: 100;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }
    
    #top-nav-bar h1 {
      margin: 0;
      font-size: 24px;
      color: var(--estaco-primary);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid #1877f2;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #crop-done-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #crop-cancel-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }

    #upload-overlay {
      display: flex;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(255, 255, 255, 0.8);
      z-index: 2000;
      justify-content: center;
      align-items: center;
    }

    .see-comments-button {
      padding: 8px 12px;
      background: var(--estaco-surface);
      border: 1px solid var(--estaco-border);
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      color: var(--estaco-text-light);
      margin-top: 8px;
      transition: background-color 0.2s;
    }
    
    .see-comments-button:hover {
      background: var(--estaco-primary-light);
    }
    
    .comments-list {
      display: none;
    }
    
    .comments-list.visible {
      display: block;
    }

    .comments-loading {
      display: none;
      width: 100%;
      text-align: center;
      padding: 10px 0;
    }
    
    .comments-loading .spinner {
      border: 2px solid rgba(0, 0, 0, 0.1);
      border-top: 2px solid var(--estaco-primary);
      width: 20px;
      height: 20px;
      animation: spin 0.8s linear infinite;
      margin: 0 auto;
    }

    #user-tag-dropdown {
      position: absolute;
      background: white;
      border: 1px solid #ddd;
      max-height: 200px;
      overflow-y: auto;
      z-index: 1000;
      width: 200px;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }
    
    .user-tag-item {
      padding: 8px;
      cursor: pointer;
    }
    
    .user-tag-item:hover {
      background: #f0f0f0;
    }

    .tag-validated {
      background-color: var(--estaco-primary-light);
      color: var(--estaco-text);
      padding: 2px 4px;
      border-radius: 4px;
      font-weight: 500;
      white-space: nowrap;
    }

    #post-content:empty::before {
      content: attr(data-placeholder);
      color: #999;
      pointer-events: none;
      display: block;
    }

  </style>
</head>
<body>
  <div id="top-nav-bar">
    <h1>Estaco</h1>
  </div>

  <div id="post-form">
    <h3 data-i18n="Create a Post">Create a Post</h3>
    <div
      id="post-content"
      contenteditable="true"
      placeholder="How's life treating ya?"
      style="
        width: 100%;
        padding: 12px;
        margin: 10px 0;
        border: 1px solid #e0e0e0;
        border-radius: 8px;
        resize: none;
        font-size: 15px;
        box-sizing: border-box;
        min-height: 60px;
        outline: none;
      "
    ></div>
    <div class="post-form-actions">
      <label for="post-media" id="post-media-label">
        <span data-i18n="Photo/Video">üì∑ Photo/Video</span>
      </label>
      <button id="post-button" data-i18n="Post">Post</button>
    </div>
    <input type="file" id="post-media" accept="image/*,video/*" style="display: none;">
    <div id="image-preview-container" style="display: none; margin: 10px 0;">
      <img id="image-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;">
    </div>
    <div id="video-preview-container" style="display: none; margin: 10px 0;">
      <video id="video-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;" controls></video>
    </div>
    <div id="post-loading" style="display: none; text-align: center; margin: 10px 0;">
      <div class="spinner"></div>
    </div>
    <p id="error-message"></p>
  </div>
  
  <div id="image-cropper-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000;">
    <div style="max-width: 500px; margin: 20px auto; background: white; padding: 20px; border-radius: 10px;">
      <h3 data-i18n="Adjust Image">Adjust Image</h3>
      <div style="margin-bottom: 10px;">
        <button class="crop-orientation-button selected" data-orientation="horizontal" data-i18n="Horizontal">Horizontal</button>
        <button class="crop-orientation-button" data-orientation="vertical" data-i18n="Vertical">Vertical</button>
      </div>
      <div style="width: 100%; height: 400px;">
        <img id="cropper-image" style="max-width: 100%;">
      </div>
      <button id="crop-done-button" data-i18n="Done">Done</button>
      <button id="crop-cancel-button" data-i18n="Cancel">Cancel</button>
    </div>
  </div>
  
  <div id="feed">
    <h3 data-i18n="Your Feed">Your Feed</h3>
  </div>
  
  <div id="bottom-nav-bar">
    <button class="nav-button" id="home-button">
      <span class="icon">üè†</span>
      <span class="label" data-i18n="Feed">Feed</span>
    </button>
    <button class="nav-button" id="notifications-button">
      <span class="icon">üîî</span>
      <span class="label">Notifications</span>
    </button>
    <button class="nav-button" id="profile-button">
      <span class="icon">üë§</span>
      <span class="label" data-i18n="Profile">Profile</span>
    </button>
  </div>

  <div id="upload-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(255, 255, 255, 0.8); z-index: 2000; justify-content: center; align-items: center;">
    <div class="spinner"></div>
  </div>

  <div id="user-tag-dropdown" style="display: none; position: absolute; background: white; border: 1px solid #ddd; max-height: 200px; overflow-y: auto; z-index: 1000; width: 200px;"></div>


  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-functions-compat.js"></script>
  <script>
    // Your Firebase config (replace with your own)
    const firebaseConfig = {
      apiKey: "AIzaSyB1txjASKb_6VPhKBpQh_Y3hoPHsNWwZ_0",
      authDomain: "estaco-add3c.firebaseapp.com",
      projectId: "estaco-add3c",
      storageBucket: "estaco-add3c.firebasestorage.app",
      messagingSenderId: "876337002297",
      appId: "1:876337002297:web:b410c373bd857bc7cd1ae8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();
    const functions = firebase.functions();

    // DOM elements
    const postContent = document.getElementById('post-content');
    const postMedia = document.getElementById('post-media');
    const postButton = document.getElementById('post-button');
    const feed = document.getElementById('feed');
    const errorMessage = document.getElementById('error-message');

    let isLoading = false; // Flag to prevent multiple simultaneous loads
    
    // Navigate to Profile Page
    document.getElementById('profile-button').addEventListener('click', () => {
      window.location.href = 'profile.html';
    });

    document.getElementById('notifications-button').addEventListener('click', () => {
      window.location.href = 'notifications.html';
    });
    
    document.getElementById('home-button').addEventListener('click', () => {
      window.location.href = 'home.html'; // or reload the current page
    });

    async function renderNewPost(post) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Get the author's profile picture
      const profilePictureHTML = await getCommentAuthorPicture(post.authorId, post.authorName);
    
      // Construct the post HTML (reuse your existing post HTML structure)
      let mediaHTML = '';
      if (post.photoURL) {
        const orientation = post.mediaOrientation || 'horizontal';
        mediaHTML = `
          <div class="media-container media-${orientation}">
            <img src="${post.photoURL}" class="post-media">
          </div>
        `;
      } else if (post.videoURL) {
        const orientation = post.mediaOrientation || 'horizontal';
        mediaHTML = `
          <div class="media-container media-${orientation}">
            <video controls class="post-media" playsinline webkit-playsinline>
              <source src="${post.videoURL}" type="video/mp4">
            </video>
          </div>
        `;
      }
    
      const postHTML = `
        <div class="post" data-post-id="${post.id}">
          <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
            <div style="display: flex; align-items: center;">
              ${profilePictureHTML}
              <h4 style="margin: 0;">${post.authorName}</h4>
            </div>
            <div style="display: flex; align-items: center;">
              <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp)}</span>
              <button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>
            </div>
          </div>
          <p>${post.content}</p>
          ${mediaHTML}
          <div class="reactions">
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="like">üëç</button>
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è</button>
            <button class="reaction-button" data-post-id="${post.id}" data-reaction="laugh">üòÇ</button>
          </div>
          <div class="comments-section">
            <div class="comment-form">
              <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}">
              <button class="comment-button" data-post-id="${post.id}">Post</button>
            </div>
            <button class="see-comments-button" data-post-id="${post.id}">See comments</button>
            <div class="comments-list" id="comments-${post.id}"></div>
          </div>
        </div>
      `;
    
      // Prepend the new post to the feed
      feed.insertAdjacentHTML('afterbegin', postHTML);
    }

    // Check if user is signed in and verified
    auth.onAuthStateChanged((user) => {
      if (!user || !user.emailVerified) {
        alert('Please sign in and verify your email to access the home feed.');
        window.location.href = 'index.html';
      } else {
        logUserFriendsWithPosts(user.uid); // Call the new function
        loadPosts();
    
        // Load user data from Firestore to get the user's language
        db.collection('users').doc(user.uid).get()
          .then((doc) => {
            if (doc.exists) {
              const userData = doc.data();
              userLanguage = userData.language || "English"; // Update globally
              updatePageLanguage(userLanguage);
            }
          })
          .catch((error) => {
            console.error("Error loading user data:", error);
          });
      }
    });

    // Global variables for the dropdown
    let currentInputElement = null;
    let currentAtPosition = -1;
    let currentQuery = "";
    
    // Function to show the dropdown with friends
    async function showUserTagDropdown(inputElement, query, atPos) {
      currentInputElement = inputElement;
      currentAtPosition = atPos;
      currentQuery = query;
    
      const dropdown = document.getElementById('user-tag-dropdown');
      dropdown.innerHTML = '';
    
      const user = auth.currentUser;
      if (!user) return;
    
      // Fetch the user's friends from Firestore
      const friendsDoc = await db.collection('friends').doc(user.uid).get();
      if (!friendsDoc.exists) return;
    
      const friends = friendsDoc.data()?.friends || [];
      const filteredFriends = friends.filter(friend =>
        friend.name.toLowerCase().includes(query.toLowerCase())
      );
    
      // Add each friend to the dropdown
      filteredFriends.forEach(friend => {
        const item = document.createElement('div');
        item.className = 'user-tag-item';
        item.textContent = friend.name;
        item.dataset.uid = friend.uid;
        item.addEventListener('click', () => {
          insertTaggedUser(inputElement, friend.name, atPos);
          hideUserTagDropdown();
        });
        dropdown.appendChild(item);
      });
    
      // Position the dropdown below the input
      const rect = inputElement.getBoundingClientRect();
      dropdown.style.display = 'block';
      dropdown.style.top = `${rect.bottom + window.scrollY}px`;
      dropdown.style.left = `${rect.left + window.scrollX}px`;
    }
    
    // Function to hide the dropdown
    function hideUserTagDropdown() {
      document.getElementById('user-tag-dropdown').style.display = 'none';
    }
    
    // Function to insert the selected user into the textarea
    function insertTaggedUser(inputElement, username, atPos) {
      const text = inputElement.value;
      const before = text.substring(0, atPos);
      const after = text.substring(inputElement.selectionStart);
      const tag = `@${username}`;
      const highlightedTag = `<span class="tag-validated" contenteditable="false">${tag}</span>`;
    
      // Use innerHTML to insert the highlighted tag
      inputElement.innerHTML = before + highlightedTag + after;
    
      // Move the cursor to the end of the tag
      const range = document.createRange();
      const selection = window.getSelection();
      const lastChild = inputElement.lastChild;
      range.setStartAfter(lastChild);
      range.collapse(true);
      selection.removeAllRanges();
      selection.addRange(range);
    
      // Focus the textarea
      inputElement.focus();
    }
    
    // Listen for @ in the post-content div
    postContent.addEventListener('input', (e) => {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const text = postContent.textContent;
      const cursorPos = range.startOffset;
      const lastAtPos = text.lastIndexOf('@', cursorPos - 1);
    
      if (lastAtPos !== -1 && cursorPos > lastAtPos) {
        const query = text.substring(lastAtPos + 1, cursorPos).trim();
        showUserTagDropdown(e.target, query, lastAtPos);
      } else {
        hideUserTagDropdown();
      }
    });
    
    // Listen for clicks inside the post-content div
    postContent.addEventListener('click', (e) => {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const text = postContent.textContent;
      const cursorPos = range.startOffset;
      const lastAtPos = text.lastIndexOf('@', cursorPos - 1);
    
      if (lastAtPos !== -1 && cursorPos > lastAtPos) {
        const query = text.substring(lastAtPos + 1, cursorPos).trim();
        showUserTagDropdown(e.target, query, lastAtPos);
      } else {
        hideUserTagDropdown();
      }
    });
    
    // Listen for keypresses to detect backspace/delete
    postContent.addEventListener('keydown', (e) => {
      if (e.key === 'Backspace' || e.key === 'Delete') {
        const selection = window.getSelection();
        const range = selection.getRangeAt(0);
        const text = postContent.textContent;
        const cursorPos = range.startOffset;
    
        // Check if the cursor is inside a validated tag
        const tags = postContent.querySelectorAll('.tag-validated');
        tags.forEach(tag => {
          const tagText = tag.textContent;
          const tagStart = text.indexOf(tagText);
          const tagEnd = tagStart + tagText.length;
    
          if (cursorPos >= tagStart && cursorPos <= tagEnd) {
            // Remove the tag if backspace/delete is pressed
            const before = text.substring(0, tagStart);
            const after = text.substring(tagEnd);
            postContent.textContent = before + after;
    
            // Move the cursor to the position after the removed tag
            const newRange = document.createRange();
            const newSelection = window.getSelection();
            newRange.setStart(postContent.firstChild, tagStart);
            newRange.collapse(true);
            newSelection.removeAllRanges();
            newSelection.addRange(newRange);
          }
        });
      }
    });
    
    // Hide dropdown when clicking outside
    document.addEventListener('click', (e) => {
      if (!e.target.matches('#post-content') && !e.target.matches('.user-tag-item')) {
        hideUserTagDropdown();
      }
    });

    let originalImageFile = null;
    let lastCropOrientation = 'horizontal';

    // Create a new post
    postButton.addEventListener('click', () => {
      errorMessage.textContent = ''; // Clear any previous error message
      const content = postContent.textContent.trim();
      const mediaFile = postMedia.files[0];
    
      if (!content) {
        alert(translations[userLanguage]["Post content cannot be empty."]);
        return;
      }
    
      // Show full-screen overlay
      document.getElementById('upload-overlay').style.display = 'flex';
      postButton.disabled = true;
    
      const user = auth.currentUser;
      user.reload().then(() => {
        const authorName = user.displayName || "Unknown User";
        const post = {
          authorId: user.uid,
          authorName: authorName,
          content: content,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          reactions: {}
        };
    
        db.collection('posts').add(post)
          .then((docRef) => {
            const uploadPromises = [];
            if (mediaFile) {
              const storageRef = storage.ref();
              const mediaType = postMedia.getAttribute('data-type');
              const mediaRef = storageRef.child(`${mediaType}s/${docRef.id}`);
              const uploadTask = mediaRef.put(mediaFile);
    
              uploadPromises.push(
                new Promise((resolve, reject) => {
                  uploadTask.on('state_changed',
                    null,
                    (error) => {
                      console.error('Upload error:', error);
                      reject(error);
                    },
                    () => {
                      uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                        const updateData = mediaType === 'image'
                          ? { photoURL: downloadURL, mediaOrientation: postMedia.getAttribute('data-orientation') }
                          : { videoURL: downloadURL, mediaOrientation: 'vertical' };
                        docRef.update(updateData).then(resolve);
                      });
                    }
                  );
                })
              );
            }
    
            Promise.all(uploadPromises)
              .then(async () => {
                alert('Post created!');
                const user = auth.currentUser;
                const authorName = user.displayName || "Unknown User";
                const newPost = {
                  id: docRef.id,
                  authorId: user.uid,
                  authorName: authorName,
                  content: content,
                  timestamp: new Date(), // Use client-side date for immediate display
                  reactions: {},
                  photoURL: mediaFile && mediaFile.type.startsWith('image/') ? URL.createObjectURL(mediaFile) : null,
                  videoURL: mediaFile && mediaFile.type.startsWith('video/') ? URL.createObjectURL(mediaFile) : null,
                  mediaOrientation: postMedia.getAttribute('data-orientation') || 'horizontal'
                };
                renderNewPost(newPost);
            
                // Add the post to the author's own feed sub-collection
                await addPostToUserFeed(user.uid, docRef.id, new Date());
            
                // Add the post to the feed sub-collections of the author's friends
                const friendUids = await getFriendUidsForUser(user.uid);
                for (const friendUid of friendUids) {
                  await addPostToUserFeed(friendUid, docRef.id, new Date());
                }
            
                postContent.textContent = '';
                postMedia.value = '';
                document.getElementById('image-preview-container').style.display = 'none';
                document.getElementById('video-preview-container').style.display = 'none';
              })
              .catch((error) => {
                errorMessage.textContent = error.message;
              })
              .finally(() => {
                // Reset the orientation button state to default (horizontal)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                  button.classList.remove('selected');
                });
                document.querySelector('.crop-orientation-button[data-orientation="horizontal"]').classList.add('selected');
            
                // Hide full-screen overlay
                document.getElementById('upload-overlay').style.display = 'none';
                postButton.disabled = false;
              });
          })
          .catch((error) => {
            errorMessage.textContent = error.message;
            // Hide loader
            document.getElementById('post-loading').style.display = 'none';
            postButton.disabled = false;
          });
      });
    });


    let lastVisiblePost = null; // To keep track of the last fetched post
    const postLimit = 3; // Number of posts to load at a time
    let isFirstLoad = true; // Add this flag at the top with your other variables
    
    async function loadPosts() {
        if (isLoading) return; // Prevent multiple simultaneous loads
        isLoading = true;
    
        const user = auth.currentUser;
        if (!user) {
            isLoading = false;
            return;
        }
    
        try {
            // 1. Get the user's feed sub-collection
            const feedRef = db.collection(`users/${user.uid}/feed`);
            let query = feedRef.orderBy('postTimestamp', 'desc');
    
            if (lastVisiblePost) {
                query = query.startAfter(lastVisiblePost.data().postTimestamp);
            }
    
            // Load only 1 post on the first load, otherwise load postLimit
            if (isFirstLoad) {
                query = query.limit(1);
            } else {
                query = query.limit(postLimit);
            }
    
            const feedSnapshot = await query.get();
    
            if (feedSnapshot.empty) {
                if (!feed.querySelector('.post')) {
                    feed.innerHTML = '<p>No posts yet. Create one!</p>';
                } else {
                    feed.innerHTML += '<p>No more posts to load.</p>';
                }
                isLoading = false;
                return;
            }
    
            // 2. Fetch the actual post data for each post ID in the feed
            const postIds = feedSnapshot.docs.map(doc => doc.data().postId);
            const postsSnapshot = await db.collection('posts')
                .where(firebase.firestore.FieldPath.documentId(), 'in', postIds)
                .get();
    
            const postsData = [];
            const feedData = feedSnapshot.docs.map(doc => ({
                postId: doc.data().postId,
                CommentsVisible: doc.data().CommentsVisible || false,
            }));
    
            postsSnapshot.forEach((doc) => {
                const post = doc.data();
                post.id = doc.id;
                // Find the corresponding feed data
                const feedDoc = feedData.find(fd => fd.postId === post.id);
                if (feedDoc) {
                    post.CommentsVisible = feedDoc.CommentsVisible;
                }
                postsData.push(post);
            });
    
            // Sort postsData to match the feed order
            postsData.sort((a, b) => {
                const aFeedDoc = feedSnapshot.docs.find(doc => doc.data().postId === a.id);
                const bFeedDoc = feedSnapshot.docs.find(doc => doc.data().postId === b.id);
                return bFeedDoc.data().postTimestamp - aFeedDoc.data().postTimestamp;
            });
    
            // Update lastVisiblePost for pagination
            lastVisiblePost = feedSnapshot.docs[feedSnapshot.docs.length - 1];
    
            await renderPosts(postsData);
    
            // After the first load, set the flag to false and load more posts
            if (isFirstLoad) {
                isFirstLoad = false;
                // setTimeout(() => loadPosts(), 100); // Small delay to ensure DOM is ready
            }
    
            isLoading = false;
        } catch (error) {
            errorMessage.textContent = error.message;
            isLoading = false;
        }
    }
    
    // Function to render posts
    async function renderPosts(postsData) {
        for (const post of postsData) {
            if (document.querySelector(`.post[data-post-id="${post.id}"]`)) continue;
          
            // Await the profile picture for the post author
            const profilePictureHTML = await getCommentAuthorPicture(post.authorId, post.authorName);
    
            // Get the current user's reaction for this post
            const userReaction = post.reactions && post.reactions[auth.currentUser.uid];
            const likeClass = userReaction && userReaction.type === 'like' ? 'selected' : '';
            const loveClass = userReaction && userReaction.type === 'love' ? 'selected' : '';
            const laughClass = userReaction && userReaction.type === 'laugh' ? 'selected' : '';
    
            const reactions = post.reactions || {};
            let likeCount = 0, loveCount = 0, laughCount = 0;
            Object.values(reactions).forEach(reaction => {
                if (reaction.type === 'like') likeCount++;
                if (reaction.type === 'love') loveCount++;
                if (reaction.type === 'laugh') laughCount++;
            });
    
            const isAuthor = auth.currentUser && auth.currentUser.uid === post.authorId;
            const likeCountHTML = isAuthor ? `<span class="reaction-count">${likeCount}</span>` : '';
            const loveCountHTML = isAuthor ? `<span class="reaction-count">${loveCount}</span>` : '';
            const laughCountHTML = isAuthor ? `<span class="reaction-count">${laughCount}</span>` : '';
            let mediaHTML = '';
            if (post.photoURL) {
                const orientation = post.mediaOrientation || 'horizontal';
                mediaHTML = `
                    <div class="media-container media-${orientation}">
                        <img src="${post.photoURL}" class="post-media">
                    </div>
                `;
            } else if (post.videoURL) {
              const orientation = post.mediaOrientation || 'horizontal';
              mediaHTML = `
                <div class="media-container media-${orientation}">
                  <video controls class="post-media" playsinline webkit-playsinline>
                    <source src="${post.videoURL}" type="video/mp4">
                  </video>
                </div>
              `;
            }
    
            // Only show the "See comments" button if CommentsVisible is true
            const seeCommentsButtonHTML = post.CommentsVisible ?
                `<button class="see-comments-button" data-post-id="${post.id}">See comments</button>` : '';
    
            let postHTML = `
                <div class="post" data-post-id="${post.id}">
                    <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center;">
                            ${profilePictureHTML}
                            <h4 style="margin: 0;">${post.authorName}</h4>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp.toDate())}</span>
                            ${isAuthor ? `<button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>` : ''}
                        </div>
                    </div>
                    <p>${post.content}</p>
                    ${mediaHTML}
                    <div class="reactions">
                        <button class="reaction-button ${likeClass}" data-post-id="${post.id}" data-reaction="like">üëç${likeCountHTML}</button>
                        <button class="reaction-button ${loveClass}" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è${loveCountHTML}</button>
                        <button class="reaction-button ${laughClass}" data-post-id="${post.id}" data-reaction="laugh">üòÇ${laughCountHTML}</button>
                    </div>
                    <div class="comments-section">
                      <div class="comment-form">
                        <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}">
                        <button class="comment-button" data-post-id="${post.id}">Post</button>
                      </div>
                      ${seeCommentsButtonHTML}
                      <div class="comments-loading" id="comments-loading-${post.id}">
                        <div class="spinner"></div>
                      </div>
                      <div class="comments-list" id="comments-${post.id}" data-loaded="false"></div>
                    </div>
                </div>
            `;
    
            // In your renderPosts function, check if the post is already rendered
            if (document.querySelector(`.post[data-post-id="${post.id}"]`)) {
              continue; // Skip if already rendered
            }
            // feed.innerHTML += postHTML; // Only append if not already present
            feed.insertAdjacentHTML('beforeend', postHTML);
        }
        setupIntersectionObserver();
    }
    
    // Call loadPosts initially to load the first batch
    loadPosts();

    function getInitialsFallback(name) {
      const firstLetter = name.charAt(0).toUpperCase();
      const pastelColors = ['#FFD1DC', '#FFE4B5', '#B5EAD7', '#C7CEEA', '#E2F0CB', '#FFB7B2'];
      const colorIndex = name.charCodeAt(0) % pastelColors.length;
      const backgroundColor = pastelColors[colorIndex];
      return `
        <div style="
          width: 40px;
          height: 40px;
          border-radius: 15%;
          background-color: ${backgroundColor};
          display: flex;
          align-items: center;
          justify-content: center;
          color: #333;
          font-weight: bold;
          font-size: 20px;
          margin-right: 10px;
        ">
          ${firstLetter}
        </div>
      `;
    }

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('reaction-button')) {
        const button = e.target;
        const postId = button.getAttribute('data-post-id');
        const reaction = button.getAttribute('data-reaction');
        const user = auth.currentUser;
        if (!user) return;
    
        // Optimistic UI update: Assume success
        const postRef = db.collection('posts').doc(postId);
        const wasSelected = button.classList.contains('selected');
    
        // Toggle the selected class
        const likeButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="like"]`);
        const loveButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="love"]`);
        const laughButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="laugh"]`);
    
        // Reset all buttons
        if (likeButton) likeButton.classList.remove('selected');
        if (loveButton) loveButton.classList.remove('selected');
        if (laughButton) laughButton.classList.remove('selected');
    
        // Select the clicked button (unless it was already selected)
        if (!wasSelected) {
          button.classList.add('selected');
        }
    
        // Fetch the post data first
        db.collection('posts').doc(postId).get().then((doc) => {
          if (!doc.exists) {
            console.error("Post does not exist!");
            return;
          }
          const post = doc.data();
    
          // Only update counts for the author's posts
          if (post.authorId === user.uid) {
            const reactions = post.reactions || {};
            let likeCount = 0, loveCount = 0, laughCount = 0;
            Object.values(reactions).forEach(r => {
              if (r.type === 'like') likeCount++;
              if (r.type === 'love') loveCount++;
              if (r.type === 'laugh') laughCount++;
            });
    
            const prevReaction = reactions[user.uid];
            if (prevReaction) {
              if (prevReaction.type === 'like') likeCount--;
              if (prevReaction.type === 'love') loveCount--;
              if (prevReaction.type === 'laugh') laughCount--;
            }
    
            if (!wasSelected) {
              if (reaction === 'like') likeCount++;
              if (reaction === 'love') loveCount++;
              if (reaction === 'laugh') laughCount++;
            }
    
            const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
            const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
            const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
    
            if (likeCountEl) likeCountEl.textContent = likeCount;
            if (loveCountEl) loveCountEl.textContent = loveCount;
            if (laughCountEl) laughCountEl.textContent = laughCount;
          }
    
          // Perform the Firestore transaction
          db.runTransaction((transaction) => {
            return transaction.get(postRef).then((doc) => {
              if (!doc.exists) throw "Post does not exist!";
              const postData = doc.data();
              const reactions = postData.reactions || {};
              const userReaction = reactions[user.uid];
          
              if (userReaction && userReaction.type === reaction) {
                delete reactions[user.uid];
              } else {
                reactions[user.uid] = {
                  type: reaction,
                  timestamp: firebase.firestore.FieldValue.serverTimestamp()
                };
              }
          
              transaction.update(postRef, { reactions });
              return post; // Return the post data for the next .then()
            });
          }).then((post) => {
            // Only add a notification if the reactor is not the author
            if (post.authorId !== user.uid) {
              // Delete old reaction notifications first
              deleteOldReactionNotifications(
                post.authorId, // Author of the post
                postId,
                user.uid // Current user (reactor)
              ).then(() => {
                // Add the new reaction notification
                addReactionNotification(
                  post.authorId, // Author of the post
                  postId,
                  user.uid, // Current user (reactor)
                  user.displayName || "Unknown User",
                  reaction,
                  firebase.firestore.FieldValue.serverTimestamp()
                );
              });
            }
          }).catch((error) => {
            console.error("Transaction failed: ", error);
            // Revert UI on failure
            if (likeButton) likeButton.classList.remove('selected');
            if (loveButton) loveButton.classList.remove('selected');
            if (laughButton) laughButton.classList.remove('selected');
            if (!wasSelected) {
              if (reaction === 'like' && likeButton) likeButton.classList.add('selected');
              if (reaction === 'love' && loveButton) loveButton.classList.add('selected');
              if (reaction === 'laugh' && laughButton) laughButton.classList.add('selected');
            }
            // Revert count for author
            if (post.authorId === user.uid) {
              db.collection('posts').doc(postId).get().then((doc) => {
                if (doc.exists) {
                  const post = doc.data();
                  const reactions = post.reactions || {};
                  let likeCount = 0, loveCount = 0, laughCount = 0;
                  Object.values(reactions).forEach(r => {
                    if (r.type === 'like') likeCount++;
                    if (r.type === 'love') loveCount++;
                    if (r.type === 'laugh') laughCount++;
                  });
                  const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
                  const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
                  const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
                  if (likeCountEl) likeCountEl.textContent = likeCount;
                  if (loveCountEl) loveCountEl.textContent = loveCount;
                  if (laughCountEl) laughCountEl.textContent = laughCount;
                }
              });
            }
          });
        });
      }
    });

    // Add event listener for comment buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const content = commentInput.value.trim();
        if (content) {
          addComment(postId, content);
          commentInput.value = '';
    
          // Automatically show the comments section after posting
          const commentsList = document.getElementById(`comments-${postId}`);
          const seeCommentsButton = document.querySelector(`.see-comments-button[data-post-id="${postId}"]`);
          if (seeCommentsButton) {
            seeCommentsButton.textContent = 'Hide comments';
            commentsList.classList.add('visible');
            loadComments(postId); // Load comments here
          }
        }
      }
    });

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('see-comments-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentsList = document.getElementById(`comments-${postId}`);
        const commentsLoading = document.getElementById(`comments-loading-${postId}`);
        const button = e.target;
    
        // Toggle visibility
        if (commentsList.classList.contains('visible')) {
          commentsList.classList.remove('visible');
          button.textContent = 'See comments';
        } else {
          commentsList.classList.add('visible');
          button.textContent = 'Hide comments';
    
          // Check if comments are already loaded
          const isLoaded = commentsList.getAttribute('data-loaded') === 'true';
          if (!isLoaded) {
            commentsLoading.style.display = 'block';
            loadComments(postId);
          }
        }
      }
    });
    
    // Function to add a comment to Firestore
    function addComment(postId, content) {
      const user = auth.currentUser;
      if (!user) return;
    
      const comment = {
        authorId: user.uid,
        authorName: user.displayName || "Unknown User",
        content: content,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      };
    
      db.collection('posts').doc(postId).collection('comments').add(comment)
        .then((docRef) => {
          // Fetch the post to get the author's UID
          db.collection('posts').doc(postId).get().then((postDoc) => {
            if (postDoc.exists) {
              const post = postDoc.data();
              // Only add a notification if the commenter is not the author
              if (post.authorId !== user.uid) {
                addCommentNotification(
                  post.authorId, // Author of the post
                  postId,
                  user.uid, // Current user (commenter)
                  user.displayName || "Unknown User",
                  content,
                  firebase.firestore.FieldValue.serverTimestamp()
                );
              }
            }
          });
    
          // Update the CommentsVisible flag for all users who have this post in their feed
          updateCommentsVisibleForPost(postId, user.uid);
        })
        .catch((error) => {
          console.error("Error adding comment: ", error);
        });
    }

    // Function to load comments for a post
    function loadComments(postId) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Show loading indicator
      const commentsLoading = document.getElementById(`comments-loading-${postId}`);
      commentsLoading.style.display = 'block';
    
      // Get the current user's friends (including themselves)
      db.collection('friends').doc(user.uid).get()
        .then((friendsDoc) => {
          const friends = friendsDoc.data()?.friends || [];
          const friendIds = friends.map(friend => friend.uid);
          friendIds.push(user.uid); // Include the current user
    
          // Fetch all comments for the post
          db.collection('posts').doc(postId).collection('comments')
            .orderBy('timestamp', 'asc')
            .get()
            .then((querySnapshot) => {
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.innerHTML = '';
              const commentPromises = [];
    
              querySnapshot.forEach((doc) => {
                const comment = doc.data();
                // Only show comments from friends
                if (friendIds.includes(comment.authorId)) {
                  const promise = getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                    const commentHTML = `
                      <div class="comment">
                        <div class="comment-author-picture">
                          ${profilePictureHTML}
                        </div>
                        <div class="comment-content">
                          <div class="comment-author-name">${comment.authorName}</div>
                          <div>${comment.content}</div>
                        </div>
                      </div>
                    `;
                    commentsList.innerHTML += commentHTML;
                  });
                  commentPromises.push(promise);
                }
              });
    
              return Promise.all(commentPromises);
            })
            .catch((error) => {
              console.error("Error loading comments: ", error);
            })
            .finally(() => {
              // Hide loading indicator and mark comments as loaded
              commentsLoading.style.display = 'none';
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.setAttribute('data-loaded', 'true');
            });
        })
        .catch((error) => {
          console.error("Error fetching friends: ", error);
          // Hide loading indicator
          commentsLoading.style.display = 'none';
        });
    }
    
    // Function to get the author's profile picture for comments
    function getCommentAuthorPicture(authorId, authorName) {
      return db.collection('users').doc(authorId).get().then((userDoc) => {
        if (userDoc.exists) {
          const userData = userDoc.data();
          const profilePictureURL = userData.profilePictureURL;
          if (profilePictureURL) {
            return `<img src="${profilePictureURL}" alt="Profile Picture" class="comment-author-picture">`;
          } else {
            // Use displayName for the initials fallback
            return getInitialsFallback(authorName || "Unknown User");
          }
        } else {
          return getInitialsFallback("Unknown User");
        }
      }).catch(() => {
        return getInitialsFallback("Unknown User");
      });
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString(); // You can customize the format as needed
    }

    // Function to log the current user's friends and their posts to the console
    async function logUserFriendsWithPosts(userId) {
        let friendIds = [];
        try {
            // Log the current user and their posts
            const userPostsSnapshot = await db.collection('posts')
                .where('authorId', '==', userId)
                .orderBy('timestamp', 'desc')
                .get();
    
            const userPosts = userPostsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
    
            console.log(`- User: ${auth.currentUser.displayName || "Current User"}`);
            if (userPosts.length > 0) {
                console.log("  Posts:");
                userPosts.forEach(post => {
                    console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                });
            } else {
                console.log("  No posts found.");
            }
    
            // Log the user's friends and their posts
            const friendsDoc = await db.collection('friends').doc(userId).get();
            if (friendsDoc.exists) {
                friendIds = friendsDoc.data()?.friends.map(friend => friend.uid) || [];
                for (const friend of friendIds) {
                    const postsSnapshot = await db.collection('posts')
                        .where('authorId', '==', friend)
                        .orderBy('timestamp', 'desc')
                        .get();
    
                    const posts = postsSnapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
    
                    console.log(`- Friend: ${friend}`);
                    if (posts.length > 0) {
                        console.log("  Posts:");
                        posts.forEach(post => {
                            console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                        });
                    } else {
                        console.log("  No posts found.");
                    }
                }
            } else {
                console.log("No friends document found for this user.");
            }
        } catch (error) {
            console.error("Error fetching user/friends or posts:", error);
        }
        return friendIds; // Return the list of friend IDs
    }

    // Throttle function to limit how often the scroll event fires
    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function() {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                    if ((Date.now() - lastRan) >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
    
    // Function to check if the user has scrolled to the bottom
    function isAtBottom() {
        return (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200;
    }

    // Replace your setupIntersectionObserver with this:
    function setupIntersectionObserver() {
      const options = { root: null, rootMargin: '200px', threshold: 0.1 };
      const observer = new IntersectionObserver(
        throttle((entries) => {
          entries.forEach((entry) => {
            if (entry.isIntersecting && entry.target === feed.lastElementChild) {
              loadPosts();
            }
          });
        }, 500),
        options
      );
      const posts = document.querySelectorAll('.post');
      if (posts.length > 0) observer.observe(posts[posts.length - 1]);
    }

    document.querySelectorAll('.orientation-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.orientation-button').forEach(b => b.classList.remove('selected'));
        button.classList.add('selected');
      });
    });

    const getSelectedOrientation = () => {
      const selectedButton = document.querySelector('.orientation-button.selected');
      return selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    };

    // Add this near your other event listeners
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-post-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const confirmDelete = confirm('Are you sure you want to delete this post?');
        if (confirmDelete) {
          deletePost(postId);
        }
      }
    });
    
    // Define the deletePost function
    async function deletePost(postId) {
      // Show the overlay
      document.getElementById('upload-overlay').style.display = 'flex';
    
      try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) {
          console.error('Post does not exist');
          return;
        }
    
        const postData = postDoc.data();
        const storage = firebase.storage();
        const authorId = postData.authorId;
    
        // Delete media from Storage if it exists
        if (postData.photoURL) {
          const photoRef = storage.refFromURL(postData.photoURL);
          await photoRef.delete();
        }
        if (postData.videoURL) {
          const videoRef = storage.refFromURL(postData.videoURL);
          await videoRef.delete();
        }
    
        // Delete the post document
        await postRef.delete();
    
        // Fetch the list of friends for the author
        const friendUids = await getFriendUidsForUser(authorId);
    
        // Add the author's UID to the list
        friendUids.push(authorId);
    
        // Delete the post from the feed sub-collections of the author and all friends
        const batch = db.batch();
        for (const uid of friendUids) {
          const feedRef = db.collection(`users/${uid}/feed`).doc(postId);
          batch.delete(feedRef);
        }
        await batch.commit();
    
        // Remove the post from the UI
        const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
        if (postElement) {
          postElement.remove();
        }
    
        alert('Post deleted successfully!');
      } catch (error) {
        console.error('Error deleting post:', error);
        alert(translations[userLanguage]["Failed to delete post. Please try again."]);
      } finally {
        // Hide the overlay
        document.getElementById('upload-overlay').style.display = 'none';
      }
    }

    postMedia.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
            document.getElementById('image-preview-container').style.display = 'none';
            document.getElementById('video-preview-container').style.display = 'none';
            return;
        }

        // Store the original file
        if (file.type.startsWith('image/')) {
            originalImageFile = file;
            lastCropOrientation = 'horizontal'; // Reset to default
        }
    
        // Reset the media input and previews
        document.getElementById('image-preview-container').style.display = 'none';
        document.getElementById('video-preview-container').style.display = 'none';
    
        if (file.type.startsWith('image/')) {
            // Handle image
            const reader = new FileReader();
            reader.onload = (e) => {
                const preview = document.getElementById('image-preview');
                const previewContainer = document.getElementById('image-preview-container');
                preview.src = e.target.result;
                previewContainer.style.display = 'block';
    
                const modal = document.getElementById('image-cropper-modal');
                const cropperImage = document.getElementById('cropper-image');
                cropperImage.src = e.target.result;
                modal.style.display = 'block';
                
                // Reset the orientation button state to default (horizontal)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.classList.remove('selected');
                });
                document.querySelector('.crop-orientation-button[data-orientation="horizontal"]').classList.add('selected');
                
                // Initialize Cropper.js with the correct aspect ratio
                let cropperAspectRatio = 16 / 9; // Default to horizontal
                let cropper = new Cropper(cropperImage, {
                    aspectRatio: cropperAspectRatio,
                    viewMode: 1,
                    dragMode: 'move',
                    guides: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    modal: true,
                });
    
                // Toggle orientation buttons (your existing code)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        const orientation = button.getAttribute('data-orientation');
                        cropperAspectRatio = orientation === 'horizontal' ? 16 / 9 : 3 / 4;
                        cropper.setAspectRatio(cropperAspectRatio);
                    });
                });
    
                // Handle "Done" button (your existing code)
                document.getElementById('crop-done-button').onclick = () => {
                    const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
                    let width, height;
                    if (selectedOrientation === 'horizontal') {
                        width = 1200;
                        height = 675;
                        quality = 0.92;
                        mimeType = 'image/jpeg';
                    } else {
                        width = 1080;
                        height = 1440;
                        quality = 1;
                        mimeType = 'image/png';
                    }
                    const canvas = cropper.getCroppedCanvas({ width, height, fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                    canvas.toBlob(
                      (blob) => {
                        const croppedFile = new File([blob], file.name, { type: 'image/jpeg' });
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(croppedFile);
                        postMedia.files = dataTransfer.files;
                        postMedia.setAttribute('data-orientation', selectedOrientation);
                        postMedia.setAttribute('data-type', 'image');
                
                        // Update the preview with the cropped image
                        const preview = document.getElementById('image-preview');
                        preview.src = URL.createObjectURL(croppedFile);
                        document.getElementById('image-preview-container').style.display = 'block';
                
                        modal.style.display = 'none';
                        cropper.destroy();
                      },
                      'image/jpeg',
                      quality
                    );
                };
    
                // Handle "Cancel" button
                document.getElementById('crop-cancel-button').onclick = () => {
                    modal.style.display = 'none';
                    cropper.destroy();
                    postMedia.value = '';
                    document.getElementById('image-preview-container').style.display = 'none';
                    document.getElementById('video-preview-container').style.display = 'none';
                };
            };
            reader.readAsDataURL(file);
        } else if (file.type.startsWith('video/')) {
            // Handle video preview
            checkVideoDuration(file, (isValid) => {
                if (!isValid) {
                    errorMessage.textContent = translations[userLanguage]["Video must be 10 seconds or shorter."];
                    postMedia.value = '';
                    document.getElementById('video-preview-container').style.display = 'none';
                } else {
                    const videoPreview = document.getElementById('video-preview');
                    const videoPreviewContainer = document.getElementById('video-preview-container');
                    videoPreview.src = URL.createObjectURL(file);
                    videoPreviewContainer.style.display = 'block';
                    postMedia.setAttribute('data-type', 'video');
                    postMedia.setAttribute('data-orientation', 'vertical');
                }
            });
        }
    });

    /**
     * Adds a post to a user's feed sub-collection.
     * @param {string} userId - The user's UID.
     * @param {string} postId - The post's ID.
     * @param {Date} timestamp - The post's timestamp.
     */
    async function addPostToUserFeed(userId, postId, timestamp) {
      try {
        const feedRef = db.collection(`users/${userId}/feed`).doc(postId);
        await feedRef.set({
          postId: postId,
          postTimestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding post to user feed:', error);
      }
    }

    /**
     * Fetches the list of friend UIDs for a user.
     * @param {string} userId - The user's UID.
     * @returns {Promise<string[]>} - Array of friend UIDs.
     */
    async function getFriendUidsForUser(userId) {
      try {
        const friendsDoc = await db.collection('friends').doc(userId).get();
        if (friendsDoc.exists) {
          const friends = friendsDoc.data()?.friends || [];
          return friends.map(friend => friend.uid);
        } else {
          return [];
        }
      } catch (error) {
        console.error('Error fetching friends:', error);
        return [];
      }
    }

    /**
     * Adds a notification to a user's notifications sub-collection.
     * @param {string} userId - The user's UID.
     * @param {string} postId - The post's ID.
     * @param {string} reactorId - The UID of the user who reacted.
     * @param {string} reactorName - The name of the user who reacted.
     * @param {string} reaction - The type of reaction (like, love, laugh).
     * @param {Date} timestamp - The timestamp of the reaction.
     */
    async function addReactionNotification(userId, postId, reactorId, reactorName, reaction, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`).doc();
        await notificationsRef.set({
          type: 'reaction',
          reactorId,
          reactorName,
          reaction,
          postId,
          timestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding reaction notification:', error);
      }
    }

    /**
     * Deletes all reaction notifications for a user on a specific post.
     * @param {string} userId - The user's UID (post author).
     * @param {string} postId - The post's ID.
     * @param {string} reactorId - The UID of the user who reacted.
     */
    async function deleteOldReactionNotifications(userId, postId, reactorId) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`);
        const querySnapshot = await notificationsRef
          .where('type', '==', 'reaction')
          .where('postId', '==', postId)
          .where('reactorId', '==', reactorId)
          .get();
    
        const batch = db.batch();
        querySnapshot.forEach((doc) => {
          batch.delete(doc.ref);
        });
        await batch.commit();
      } catch (error) {
        console.error('Error deleting old reaction notifications:', error);
      }
    }

    /**
     * Adds a comment notification to a user's notifications sub-collection.
     * @param {string} userId - The user's UID (post author).
     * @param {string} postId - The post's ID.
     * @param {string} commenterId - The UID of the user who commented.
     * @param {string} commenterName - The name of the user who commented.
     * @param {string} commentContent - The content of the comment.
     * @param {Date} timestamp - The timestamp of the comment.
     */
    async function addCommentNotification(userId, postId, commenterId, commenterName, commentContent, timestamp) {
      try {
        const notificationsRef = db.collection(`users/${userId}/notifications`).doc();
        await notificationsRef.set({
          type: 'comment',
          reactorId: commenterId,
          reactorName: commenterName,
          commentContent: commentContent,
          postId: postId,
          timestamp: timestamp,
        });
      } catch (error) {
        console.error('Error adding comment notification:', error);
      }
    }

    /**
     * Updates the CommentsVisible flag for all users who have the post in their feed and are friends with the commenter.
     * @param {string} postId - The ID of the post.
     * @param {string} commenterId - The UID of the user who commented.
     */
    async function updateCommentsVisibleForPost(postId, commenterId) {
      try {
        // 1. Get the post to find the author
        const postDoc = await db.collection('posts').doc(postId).get();
        if (!postDoc.exists) {
          console.log('Post does not exist.');
          return;
        }
        const post = postDoc.data();
        const authorId = post.authorId;
    
        // 2. Create a batch for updates
        const batch = db.batch();
    
        // 3. Always update the CommentsVisible flag for the post author
        const authorFeedDocRef = db.collection(`users/${authorId}/feed`).doc(postId);
        batch.update(authorFeedDocRef, { CommentsVisible: true });
    
        // 4. Always update the CommentsVisible flag for the commenter
        const commenterFeedDocRef = db.collection(`users/${commenterId}/feed`).doc(postId);
        batch.update(commenterFeedDocRef, { CommentsVisible: true });
    
        // 5. Get the author's friends (including the author)
        const friendsDoc = await db.collection('friends').doc(authorId).get();
        const friends = friendsDoc.exists ? friendsDoc.data()?.friends || [] : [];
        const friendIds = friends.map(friend => friend.uid);
        friendIds.push(authorId); // Include the author
    
        // 6. For each friend, check if they have the post in their feed
        for (const userId of friendIds) {
          if (userId === authorId || userId === commenterId) continue; // Skip author and commenter, already handled
    
          const feedDocRef = db.collection(`users/${userId}/feed`).doc(postId);
          const feedDoc = await feedDocRef.get();
          if (feedDoc.exists) {
            // 7. Check if the commenter is a friend of this user
            const userFriendsDoc = await db.collection('friends').doc(userId).get();
            if (userFriendsDoc.exists) {
              const userFriends = userFriendsDoc.data()?.friends || [];
              const userFriendIds = userFriends.map(friend => friend.uid);
              userFriendIds.push(userId); // Include the user themselves
    
              if (userFriendIds.includes(commenterId)) {
                // 8. Update the CommentsVisible flag to true
                batch.update(feedDocRef, { CommentsVisible: true });
              }
            }
          }
        }
    
        // 9. Commit the batch update
        await batch.commit();
        console.log('Updated CommentsVisible flag for users who have this post in their feed.');
      } catch (error) {
        console.error('Error updating CommentsVisible flag:', error);
      }
    }

    document.getElementById('image-preview').addEventListener('click', () => {
        if (originalImageFile) {
            const modal = document.getElementById('image-cropper-modal');
            const cropperImage = document.getElementById('cropper-image');
            const reader = new FileReader();
            reader.onload = (e) => {
                cropperImage.src = e.target.result;
                modal.style.display = 'block';
    
                // Get the currently selected orientation button
                const selectedButton = document.querySelector('.crop-orientation-button.selected');
                const currentOrientation = selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    
                // Set the button state to match the current orientation
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.classList.remove('selected');
                    if (button.getAttribute('data-orientation') === currentOrientation) {
                        button.classList.add('selected');
                    }
                });
    
                // Initialize Cropper.js with the current aspect ratio
                let cropperAspectRatio = currentOrientation === 'horizontal' ? 16 / 9 : 3 / 4;
                let cropper = new Cropper(cropperImage, {
                    aspectRatio: cropperAspectRatio,
                    viewMode: 1,
                    dragMode: 'move',
                    guides: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    modal: true,
                });
    
                // Toggle orientation buttons
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        const orientation = button.getAttribute('data-orientation');
                        lastCropOrientation = orientation; // Update the last used orientation
                        cropperAspectRatio = orientation === 'horizontal' ? 16 / 9 : 3 / 4;
                        cropper.setAspectRatio(cropperAspectRatio);
                    });
                });
    
                // Handle "Done" button
                document.getElementById('crop-done-button').onclick = () => {
                    const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
                    let width, height, quality, mimeType;
                    if (selectedOrientation === 'horizontal') {
                        width = 1200;
                        height = 675;
                        quality = 0.92;
                        mimeType = 'image/jpeg';
                    } else {
                        width = 1080;
                        height = 1440;
                        quality = 1;
                        mimeType = 'image/png';
                    }
                    const canvas = cropper.getCroppedCanvas({ width, height, fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                    canvas.toBlob(
                        (blob) => {
                            const croppedFile = new File([blob], 'cropped-image.jpg', { type: mimeType });
                            const dataTransfer = new DataTransfer();
                            dataTransfer.items.add(croppedFile);
                            postMedia.files = dataTransfer.files;
                            postMedia.setAttribute('data-orientation', selectedOrientation);
                            postMedia.setAttribute('data-type', 'image');
    
                            // Update the preview with the cropped image
                            const preview = document.getElementById('image-preview');
                            preview.src = URL.createObjectURL(croppedFile);
                            modal.style.display = 'none';
                            cropper.destroy();
                        },
                        mimeType,
                        quality
                    );
                };
    
                // Handle "Cancel" button
                document.getElementById('crop-cancel-button').onclick = () => {
                    modal.style.display = 'none';
                    cropper.destroy();
                };
            };
            reader.readAsDataURL(originalImageFile);
        }
    });

    function checkVideoDuration(file, callback) {
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.onloadedmetadata = () => {
        window.URL.revokeObjectURL(video.src);
        callback(video.duration <= 10);
      };
      video.src = URL.createObjectURL(file);
    }

    async function postHasComments(postId) {
      const commentsSnapshot = await db.collection('posts').doc(postId).collection('comments').get();
      return !commentsSnapshot.empty;
    }

    // Load posts when page loads
    window.onload = loadPosts;

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('ServiceWorker registration successful');
            // Force update check
            registration.update();
          })
          .catch((err) => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }

    let userLanguage = "English"; // Define globally
    // Update placeholders
    document.getElementById('post-content').placeholder = translations[userLanguage]["How's life treating ya?"];
    document.querySelectorAll('.comment-input').forEach(input => {
      input.placeholder = translations[userLanguage]["Write a comment..."];
    });

    // Translations dictionary
    const translations = {
      English: {
        "Create a Post": "Create a Post",
        "How's life treating ya?": "How's life treating ya?",
        "Photo/Video": "Photo/Video",
        "Post": "Post",
        "Adjust Image": "Adjust Image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Done",
        "Cancel": "Cancel",
        "Video must be 10 seconds or shorter.": "Video must be 10 seconds or shorter.",
        "Post created!": "Post created!",
        "Are you sure you want to delete this post?": "Are you sure you want to delete this post?",
        "Post deleted successfully!": "Post deleted successfully!",
        "Failed to delete post. Please try again.": "Failed to delete post. Please try again.",
        "Your Feed": "Your Feed",
        "Feed": "Feed",
        "Profile": "Profile",
        "Post content cannot be empty.": "Post content cannot be empty.",
        "Write a comment...": "Write a comment...",
        "Transaction failed: ": "Transaction failed: ",
      },
      French: {
        "Create a Post": "Cr√©er une publication",
        "How's life treating ya?": "Comment √ßa va ?",
        "Photo/Video": "Photo/Vid√©o",
        "Post": "Publier",
        "Adjust Image": "Ajuster l'image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Termin√©",
        "Cancel": "Annuler",
        "Video must be 10 seconds or shorter.": "La vid√©o doit durer 10 secondes ou moins.",
        "Post created!": "Publication cr√©√©e !",
        "Are you sure you want to delete this post?": "√ätes-vous s√ªr de vouloir supprimer cette publication ?",
        "Post deleted successfully!": "Publication supprim√©e avec succ√®s !",
        "Failed to delete post. Please try again.": "√âchec de la suppression de la publication. Veuillez r√©essayer.",
        "Your Feed": "Votre fil d'actualit√©",
        "Feed": "Fil d'actualit√©",
        "Profile": "Profil",
        "Post content cannot be empty.": "Le contenu de la publication ne peut pas √™tre vide.",
        "Write a comment...": "√âcrivez un commentaire...",
        "Transaction failed: ": "√âchec de la transaction : ",
      },
      Korean: {
        "Create a Post": "Í≤åÏãúÎ¨º ÏûëÏÑ±",
        "How's life treating ya?": "ÏöîÏ¶ò Ïñ¥ÎñªÍ≤å ÏßÄÎÇ¥ÏÑ∏Ïöî?",
        "Photo/Video": "ÏÇ¨ÏßÑ/ÎπÑÎîîÏò§",
        "Post": "Í≤åÏãú",
        "Adjust Image": "Ïù¥ÎØ∏ÏßÄ Ï°∞Ï†ï",
        "Horizontal": "Í∞ÄÎ°ú",
        "Vertical": "ÏÑ∏Î°ú",
        "Done": "ÏôÑÎ£å",
        "Cancel": "Ï∑®ÏÜå",
        "Video must be 10 seconds or shorter.": "ÎπÑÎîîÏò§Îäî 10Ï¥à Ïù¥ÌïòÏó¨Ïïº Ìï©ÎãàÎã§.",
        "Post created!": "Í≤åÏãúÎ¨ºÏù¥ ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§!",
        "Are you sure you want to delete this post?": "Ïù¥ Í≤åÏãúÎ¨ºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        "Post deleted successfully!": "Í≤åÏãúÎ¨ºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!",
        "Failed to delete post. Please try again.": "Í≤åÏãúÎ¨º ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
        "Your Feed": "ÌîºÎìú",
        "Feed": "ÌîºÎìú",
        "Profile": "ÌîÑÎ°úÌïÑ",
        "Post content cannot be empty.": "Í≤åÏãúÎ¨º ÎÇ¥Ïö©Ïù¥ ÎπÑÏñ¥ ÏûàÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        "Write a comment...": "ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±ÌïòÏÑ∏Ïöî...",
        "Transaction failed: ": "Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®: ",
      }
    };
    
    // Function to update the page language
    function updatePageLanguage(language) {
      const lang = translations[language] || translations["English"];
      document.querySelectorAll("[data-i18n]").forEach((element) => {
        const key = element.getAttribute("data-i18n");
        if (lang[key]) {
          element.textContent = lang[key];
        }
      });
    }

  </script>
</body>
</html>
