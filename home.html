<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Estaco</title>
  <link rel="manifest" href="/manifest.json">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
  <style>
    :root {
      --estaco-primary: #8B8E6F; /* Light olive */
      --estaco-primary-light: #A7A98C; /* Lighter olive for hover states */
      --estaco-secondary: #E2725B; /* Soft terracotta */
      --estaco-accent: #FFD700; /* Warm yellow (for buttons, accents) */
      --estaco-background: #FFFFFF;
      --estaco-surface: #F9F9F9;
      --estaco-text: #333333;
      --estaco-text-light: #666666;
      --estaco-border: #E0E0E0;
      --estaco-error: #F44336;
      --estaco-success: #4CAF50;
    }

    body {
        font-family: Arial, sans-serif;
        max-width: 100%; /* Remove fixed max-width */
        margin: 0;
        padding: 0; /* Remove padding to allow full-width media */
        padding-bottom: 60px;
        padding-top: 60px;
    }
    #post-form {
      margin-bottom: 20px;
      padding: 15px;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      background-color: #ffffff;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    #post-photo {
      width: 95%;
      padding: 8px;
      margin: 5px 0;
    }
    #post-content {
      width: 100%;
      padding: 12px;
      margin: 10px 0;
      border: 1px solid #e0e0e0;
      border-radius: 8px;
      resize: none;
      font-size: 15px;
      box-sizing: border-box;
    }
    input, textarea {
      -webkit-text-size-adjust: 100%;
      -moz-text-size-adjust: 100%;
      -ms-text-size-adjust: 100%;
      text-size-adjust: 100%;
    }
    html, body {
      overflow-x: hidden;
      width: 100%;
    }
    #post-media-label {
      display: inline-flex;
      align-items: center;
      padding: 10px 15px;
      background: var(--estaco-surface);
      color: var(--estaco-text);
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-right: 10px;
      transition: background-color 0.2s;
    }
    #post-button {
      padding: 10px 20px;
      background-color: var(--estaco-primary); /* Light olive */
      color: white;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 15px;
      font-weight: 600;
      transition: background-color 0.2s;
    }
    .post-form-actions {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 10px;
    }
    #feed {
      margin-top: 20px;
      width: 100%;
    }
    .post {
      padding: 10px;
      border: 1px solid var(--estaco-border);
      border-radius: 5px;
      margin-bottom: 10px;
      margin-left: 0;
      margin-right: 0;
      background: var(--estaco-background);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }
    #error-message {
      color: red;
    }
    .post-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .post-author-picture {
      width: 40px;
      height: 40px;
      border-radius: 15%;
      margin-right: 10px;
    }
    .reactions {
      margin-top: 10px;
    }
    .reaction-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-right: 5px;
    }
    .reaction-count {
      font-size: 12px;
      margin-left: 3px;
      color: #666;
    }
    .reaction-button.selected {
      background-color: rgba(139, 142, 111, 0.1);
      border-radius: 4px;
      padding: 2px 4px;
    }
    .comments-section {
      margin-top: 10px;
      border-top: 1px solid var(--estaco-border);
      padding-top: 10px;
    }
    .comment-form {
      display: flex;
      margin-bottom: 10px;
    }
    .comment-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .comment-button {
      padding: 8px 12px;
      background: var(--estaco-accent);
      border: none;
      border-radius: 4px;
      margin-left: 5px;
      cursor: pointer;
    }
    .comment {
      display: flex;
      margin-bottom: 8px;
      align-items: flex-start;
    }
    .comment-author-picture {
      width: 30px;
      height: 30px;
      border-radius: 10%; /* Adjust this value to control the roundness */
      margin-right: 8px;
    }
    .comment-content {
      background: var(--estaco-surface);
      padding: 8px 12px;
      border-radius: 8px;
      flex: 1;
    }
    .comment-author-name {
      font-weight: bold;
      margin-bottom: 2px;
    }
    .post-timestamp {
      text-align: right;
      font-size: 12px;
      color: var(--estaco-text-light);
      margin-top: -15px; /* Adjust as needed to move it closer to the header */
    }
    .media-container {
      position: relative;
      margin-top: 10px;
      overflow: hidden;
      background-color: var(--estaco-surface);
    }
    .media-horizontal,
    .media-vertical {
      width: 100%; /* Full width of the parent container */
      height: auto; /* Let height be calculated based on aspect ratio */
      position: relative;
      overflow: hidden;
      background-color: transparent; /* Remove grey background */
      margin: 0; /* Remove any default margins */
    }
    
    /* Horizontal media: 16:9 aspect ratio */
    .media-horizontal {
        aspect-ratio: 16 / 9;
    }
    
    /* Vertical media: 9:16 aspect ratio */
    .media-vertical {
        aspect-ratio: 9 / 16;
    }
    
    /* Media inside the container */
    .media-container img,
    .media-container video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: cover; /* Use cover to fill the container */
    }
    .orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .orientation-button.selected {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }
    .delete-post-button {
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .crop-orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .crop-orientation-button.selected {
      background: var(--estaco-primary);
      color: white;
      border-color: var(--estaco-primary);
    }
    #image-preview-container {
        display: none;
        margin: 10px 0;
        padding: 10px;
        border: 1px solid #ddd;
        border-radius: 4px;
        background: #f9f9f9;
    }
    #image-preview {
        max-width: 100%;
        max-height: 200px;
        border-radius: 4px;
        display: block;
        margin: 0 auto;
    }
    #post-media {
        display: none;
    }
    .video-wrapper {
        position: relative;
        width: 100%;
        height: 100%;
    }
    
    .custom-play-button {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 0, 0, 0.7);
        color: white;
        border: none;
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 20px;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
    }
    
    .custom-play-button.hidden {
        display: none;
    }

    #bottom-nav-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: space-around;
      align-items: center;
      background-color: white;
      border-top: 1px solid #e0e0e0;
      padding: 8px 0;
      z-index: 100;
      box-shadow: 0 -2px 5px rgba(0, 0, 0, 0.05);
    }
    
    .nav-button {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      cursor: pointer;
      padding: 6px 12px;
      color: #333;
      font-size: 12px;
    }
    
    .nav-button .icon {
      font-size: 24px;
      margin-bottom: 4px;
    }
    
    .nav-button .label {
      font-size: 12px;
    }

    #top-nav-bar {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: white;
      border-bottom: 1px solid #e0e0e0;
      padding: 10px 0;
      z-index: 100;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
    }
    
    #top-nav-bar h1 {
      margin: 0;
      font-size: 24px;
      color: var(--estaco-primary);
      font-family: 'Inter', sans-serif;
      font-weight: 500;
    }

    .spinner {
      border: 4px solid rgba(0, 0, 0, 0.1);
      border-radius: 50%;
      border-top: 4px solid #1877f2;
      width: 30px;
      height: 30px;
      animation: spin 1s linear infinite;
      margin: 0 auto;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }

    #crop-done-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-primary);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #crop-cancel-button {
      margin-top: 10px;
      padding: 8px 12px;
      background: var(--estaco-error);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      margin-left: 10px;
    }

  </style>
</head>
<body>
  <div id="top-nav-bar">
    <h1>Estaco</h1>
  </div>

  <div id="post-form">
    <h3 data-i18n="Create a Post">Create a Post</h3>
    <textarea id="post-content" placeholder="How's life treating ya?" rows="3"></textarea>
    <div class="post-form-actions">
      <label for="post-media" id="post-media-label">
        <span data-i18n="Photo/Video">üì∑ Photo/Video</span>
      </label>
      <button id="post-button" data-i18n="Post">Post</button>
    </div>
    <input type="file" id="post-media" accept="image/*,video/*" style="display: none;">
    <div id="image-preview-container" style="display: none; margin: 10px 0;">
      <img id="image-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;">
    </div>
    <div id="video-preview-container" style="display: none; margin: 10px 0;">
      <video id="video-preview" style="max-width: 100%; max-height: 200px; border-radius: 4px;" controls></video>
    </div>
    <div id="post-loading" style="display: none; text-align: center; margin: 10px 0;">
      <div class="spinner"></div>
    </div>
    <p id="error-message"></p>
  </div>
  
  <div id="image-cropper-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 1000;">
    <div style="max-width: 500px; margin: 20px auto; background: white; padding: 20px; border-radius: 10px;">
      <h3 data-i18n="Adjust Image">Adjust Image</h3>
      <div style="margin-bottom: 10px;">
        <button class="crop-orientation-button selected" data-orientation="horizontal" data-i18n="Horizontal">Horizontal</button>
        <button class="crop-orientation-button" data-orientation="vertical" data-i18n="Vertical">Vertical</button>
      </div>
      <div style="width: 100%; height: 400px;">
        <img id="cropper-image" style="max-width: 100%;">
      </div>
      <button id="crop-done-button" data-i18n="Done">Done</button>
      <button id="crop-cancel-button" data-i18n="Cancel">Cancel</button>
    </div>
  </div>
  
  <div id="feed">
    <h3 data-i18n="Your Feed">Your Feed</h3>
  </div>
  
  <div id="bottom-nav-bar">
    <button class="nav-button" id="home-button">
      <span class="icon">üè†</span>
      <span class="label" data-i18n="Feed">Feed</span>
    </button>
    <button class="nav-button" id="notifications-button">
      <span class="icon">üîî</span>
      <span class="label">Notifications</span>
    </button>
    <button class="nav-button" id="profile-button">
      <span class="icon">üë§</span>
      <span class="label" data-i18n="Profile">Profile</span>
    </button>
  </div>

  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-functions-compat.js"></script>
  <script>
    // Your Firebase config (replace with your own)
    const firebaseConfig = {
      apiKey: "AIzaSyB1txjASKb_6VPhKBpQh_Y3hoPHsNWwZ_0",
      authDomain: "estaco-add3c.firebaseapp.com",
      projectId: "estaco-add3c",
      storageBucket: "estaco-add3c.firebasestorage.app",
      messagingSenderId: "876337002297",
      appId: "1:876337002297:web:b410c373bd857bc7cd1ae8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();
    const functions = firebase.functions();

    // DOM elements
    const postContent = document.getElementById('post-content');
    const postMedia = document.getElementById('post-media');
    const postButton = document.getElementById('post-button');
    const feed = document.getElementById('feed');
    const errorMessage = document.getElementById('error-message');

    let isLoading = false; // Flag to prevent multiple simultaneous loads
    
    // Navigate to Profile Page
    document.getElementById('profile-button').addEventListener('click', () => {
      window.location.href = 'profile.html';
    });

    document.getElementById('notifications-button').addEventListener('click', () => {
      window.location.href = 'notifications.html';
    });
    
    document.getElementById('home-button').addEventListener('click', () => {
      window.location.href = 'home.html'; // or reload the current page
    });

    // Check if user is signed in and verified
    auth.onAuthStateChanged((user) => {
      if (!user || !user.emailVerified) {
        alert('Please sign in and verify your email to access the home feed.');
        window.location.href = 'index.html';
      } else {
        logUserFriendsWithPosts(user.uid); // Call the new function
        loadPosts();
    
        // Load user data from Firestore to get the user's language
        db.collection('users').doc(user.uid).get()
          .then((doc) => {
            if (doc.exists) {
              const userData = doc.data();
              userLanguage = userData.language || "English"; // Update globally
              updatePageLanguage(userLanguage);
            }
          })
          .catch((error) => {
            console.error("Error loading user data:", error);
          });
      }
    });

    // Create a new post
    postButton.addEventListener('click', () => {
      errorMessage.textContent = ''; // Clear any previous error message
      const content = postContent.value;
      const mediaFile = postMedia.files[0];
    
      if (!content) {
        alert(translations[userLanguage]["Post content cannot be empty."]);
        return;
      }
    
      // Show loader
      document.getElementById('post-loading').style.display = 'block';
      postButton.disabled = true;
    
      const user = auth.currentUser;
      user.reload().then(() => {
        const authorName = user.displayName || "Unknown User";
        const post = {
          authorId: user.uid,
          authorName: authorName,
          content: content,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          reactions: {}
        };
    
        db.collection('posts').add(post)
          .then((docRef) => {
            const uploadPromises = [];
            if (mediaFile) {
              const storageRef = storage.ref();
              const mediaType = postMedia.getAttribute('data-type');
              const mediaRef = storageRef.child(`${mediaType}s/${docRef.id}`);
              const uploadTask = mediaRef.put(mediaFile);
    
              uploadPromises.push(
                new Promise((resolve, reject) => {
                  uploadTask.on('state_changed',
                    null,
                    (error) => {
                      console.error('Upload error:', error);
                      reject(error);
                    },
                    () => {
                      uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                        const updateData = mediaType === 'image'
                          ? { photoURL: downloadURL, mediaOrientation: postMedia.getAttribute('data-orientation') }
                          : { videoURL: downloadURL, mediaOrientation: 'vertical' };
                        docRef.update(updateData).then(resolve);
                      });
                    }
                  );
                })
              );
            }
    
            Promise.all(uploadPromises)
              .then(() => {
                alert('Post created!');
    
                // --- NEW CODE: Prepend the new post to the feed ---
                const newPost = {
                  id: docRef.id,
                  authorId: user.uid,
                  authorName: authorName,
                  content: content,
                  timestamp: new Date(), // Use current date for display
                  reactions: {},
                  ...(mediaFile && mediaFile.type.startsWith('image/') && { photoURL: URL.createObjectURL(mediaFile) }),
                  ...(mediaFile && mediaFile.type.startsWith('video/') && { videoURL: URL.createObjectURL(mediaFile) }),
                  mediaOrientation: postMedia.getAttribute('data-orientation') || 'horizontal',
                };
                renderPosts([newPost]);
                // --- END NEW CODE ---
    
                postContent.value = '';
                postMedia.value = '';
                document.getElementById('image-preview-container').style.display = 'none';
                document.getElementById('video-preview-container').style.display = 'none';
              })
              .catch((error) => {
                errorMessage.textContent = error.message;
              })
              .finally(() => {
                // Hide loader
                document.getElementById('post-loading').style.display = 'none';
                postButton.disabled = false;
              });
          })
          .catch((error) => {
            errorMessage.textContent = error.message;
            // Hide loader
            document.getElementById('post-loading').style.display = 'none';
            postButton.disabled = false;
          });
      });
    });

    let lastVisiblePost = null; // To keep track of the last fetched post
    const postLimit = 3; // Number of posts to load at a time
    let isFirstLoad = true; // Add this flag at the top with your other variables
    
    async function loadPosts() {
        if (isLoading) return; // Prevent multiple simultaneous loads
        isLoading = true;
    
        const user = auth.currentUser;
        if (!user) {
            isLoading = false;
            return;
        }
    
        const friendIds = await logUserFriendsWithPosts(user.uid);
        friendIds.push(user.uid);
    
        let query = db.collection('posts')
            .where('authorId', 'in', friendIds)
            .orderBy('timestamp', 'desc');
    
        if (lastVisiblePost) {
            query = query.startAfter(lastVisiblePost);
        }
    
        // Load only 1 post on the first load
        if (isFirstLoad) {
            query = query.limit(1);
        } else {
            query = query.limit(postLimit);
        }
    
        query.get().then(async (querySnapshot) => {
            if (querySnapshot.empty) {
                if (!feed.querySelector('.post')) {
                    feed.innerHTML = '<p>No posts yet. Create one!</p>';
                } else {
                    feed.innerHTML += '<p>No more posts to load.</p>';
                }
                isLoading = false;
                return;
            }
        
            const postsData = [];
            querySnapshot.forEach((doc) => {
                const post = doc.data();
                post.id = doc.id;
                postsData.push(post);
                lastVisiblePost = doc; // Update lastVisiblePost for pagination
            });
        
            await renderPosts(postsData);
        
            // After the first load, set the flag to false and load more posts
            if (isFirstLoad) {
                isFirstLoad = false;
                setTimeout(() => loadPosts(), 100); // Small delay to ensure DOM is ready
            }
        
            isLoading = false;
        }).catch((error) => {
            errorMessage.textContent = error.message;
            isLoading = false;
        });
    }
    
    // Function to render posts
    async function renderPosts(postsData) {
        for (const post of postsData) {
            // Await the profile picture for the post author
            const profilePictureHTML = await getCommentAuthorPicture(post.authorId, post.authorName);
    
            // Get the current user's reaction for this post
            const userReaction = post.reactions && post.reactions[auth.currentUser.uid];
            const likeClass = userReaction && userReaction.type === 'like' ? 'selected' : '';
            const loveClass = userReaction && userReaction.type === 'love' ? 'selected' : '';
            const laughClass = userReaction && userReaction.type === 'laugh' ? 'selected' : '';
            
            const reactions = post.reactions || {};
            let likeCount = 0, loveCount = 0, laughCount = 0;
            Object.values(reactions).forEach(reaction => {
                if (reaction.type === 'like') likeCount++;
                if (reaction.type === 'love') loveCount++;
                if (reaction.type === 'laugh') laughCount++;
            });
    
            const isAuthor = auth.currentUser && auth.currentUser.uid === post.authorId;
            const likeCountHTML = isAuthor ? `<span class="reaction-count">${likeCount}</span>` : '';
            const loveCountHTML = isAuthor ? `<span class="reaction-count">${loveCount}</span>` : '';
            const laughCountHTML = isAuthor ? `<span class="reaction-count">${laughCount}</span>` : '';
            let mediaHTML = '';
            if (post.photoURL) {
                const orientation = post.mediaOrientation || 'horizontal';
                mediaHTML = `
                    <div class="media-container media-${orientation}">
                        <img src="${post.photoURL}" class="post-media">
                    </div>
                `;
            } else if (post.videoURL) {
              const orientation = post.mediaOrientation || 'horizontal';
              mediaHTML = `
                <div class="media-container media-${orientation}">
                  <video controls class="post-media" playsinline webkit-playsinline>
                    <source src="${post.videoURL}" type="video/mp4">
                  </video>
                </div>
              `;
            }
    
            let postHTML = `
                <div class="post" data-post-id="${post.id}">
                    <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center;">
                            ${profilePictureHTML}
                            <h4 style="margin: 0;">${post.authorName}</h4>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp.toDate())}</span>
                            ${isAuthor ? `<button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>` : ''}
                        </div>
                    </div>
                    <p>${post.content}</p>
                    ${mediaHTML}
                    <div class="reactions">
                        <button class="reaction-button ${likeClass}" data-post-id="${post.id}" data-reaction="like">üëç${likeCountHTML}</button>
                        <button class="reaction-button ${loveClass}" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è${loveCountHTML}</button>
                        <button class="reaction-button ${laughClass}" data-post-id="${post.id}" data-reaction="laugh">üòÇ${laughCountHTML}</button>
                    </div>
                    <div class="comments-section">
                        <div class="comment-form">
                            <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}">
                            <button class="comment-button" data-post-id="${post.id}">Post</button>
                        </div>
                        <div class="comments-list" id="comments-${post.id}">
                            <!-- Comments will be loaded here -->
                        </div>
                    </div>
                </div>
            `;
    
            // In your renderPosts function, check if the post is already rendered
            if (document.querySelector(`.post[data-post-id="${post.id}"]`)) {
              continue; // Skip if already rendered
            }
            feed.innerHTML += postHTML; // Only append if not already present
    
            // Load comments for each post
            loadComments(post.id);
        }
        setupIntersectionObserver();
    }
    
    // Call loadPosts initially to load the first batch
    loadPosts();

    function getInitialsFallback(name) {
      const firstLetter = name.charAt(0).toUpperCase();
      const pastelColors = ['#FFD1DC', '#FFE4B5', '#B5EAD7', '#C7CEEA', '#E2F0CB', '#FFB7B2'];
      const colorIndex = name.charCodeAt(0) % pastelColors.length;
      const backgroundColor = pastelColors[colorIndex];
      return `
        <div style="
          width: 40px;
          height: 40px;
          border-radius: 15%;
          background-color: ${backgroundColor};
          display: flex;
          align-items: center;
          justify-content: center;
          color: #333;
          font-weight: bold;
          font-size: 20px;
          margin-right: 10px;
        ">
          ${firstLetter}
        </div>
      `;
    }

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('reaction-button')) {
        const button = e.target;
        const postId = button.getAttribute('data-post-id');
        const reaction = button.getAttribute('data-reaction');
        const user = auth.currentUser;
        if (!user) return;
    
        // Optimistic UI update: Assume success
        const postRef = db.collection('posts').doc(postId);
        const wasSelected = button.classList.contains('selected');
    
        // Toggle the selected class
        const likeButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="like"]`);
        const loveButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="love"]`);
        const laughButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="laugh"]`);
    
        // Reset all buttons
        if (likeButton) likeButton.classList.remove('selected');
        if (loveButton) loveButton.classList.remove('selected');
        if (laughButton) laughButton.classList.remove('selected');
    
        // Select the clicked button (unless it was already selected)
        if (!wasSelected) {
          button.classList.add('selected');
        }
    
        // Only update counts for the author's posts
        db.collection('posts').doc(postId).get().then((doc) => {
          if (doc.exists) {
            const post = doc.data();
            if (post.authorId === user.uid) {
              // Count reactions
              const reactions = post.reactions || {};
              let likeCount = 0, loveCount = 0, laughCount = 0;
              Object.values(reactions).forEach(r => {
                if (r.type === 'like') likeCount++;
                if (r.type === 'love') loveCount++;
                if (r.type === 'laugh') laughCount++;
              });
        
              // Get the previous reaction (if any)
              const prevReaction = reactions[user.uid];
        
              // If there was a previous reaction, decrement its count
              if (prevReaction) {
                if (prevReaction.type === 'like') likeCount--;
                if (prevReaction.type === 'love') loveCount--;
                if (prevReaction.type === 'laugh') laughCount--;
              }
    
              // If the clicked button was not selected, increment its count
              if (!wasSelected) {
                if (reaction === 'like') likeCount++;
                if (reaction === 'love') loveCount++;
                if (reaction === 'laugh') laughCount++;
              }
    
              // Update the UI for the author
              const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
              const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
              const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
    
              if (likeCountEl) likeCountEl.textContent = likeCount;
              if (loveCountEl) loveCountEl.textContent = loveCount;
              if (laughCountEl) laughCountEl.textContent = laughCount;
            }
          }
        });
    
        // Perform the Firestore transaction
        db.runTransaction((transaction) => {
          return transaction.get(postRef).then((doc) => {
            if (!doc.exists) throw "Post does not exist!";
            const postData = doc.data();
            const reactions = postData.reactions || {};
            const userReaction = reactions[user.uid];
        
            if (userReaction && userReaction.type === reaction) {
              delete reactions[user.uid];
            } else {
              reactions[user.uid] = {
                type: reaction,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
              };
            }
        
            transaction.update(postRef, { reactions });
          });
        }).catch((error) => {
          console.error(translations[userLanguage]["Transaction failed: "], error);
          // Revert UI on failure
          if (likeButton) likeButton.classList.remove('selected');
          if (loveButton) loveButton.classList.remove('selected');
          if (laughButton) laughButton.classList.remove('selected');
          if (!wasSelected) {
            if (reaction === 'like' && likeButton) likeButton.classList.add('selected');
            if (reaction === 'love' && loveButton) loveButton.classList.add('selected');
            if (reaction === 'laugh' && laughButton) laughButton.classList.add('selected');
          }
          // Revert count for author
          if (post.authorId === user.uid) {
            db.collection('posts').doc(postId).get().then((doc) => {
              if (doc.exists) {
                const post = doc.data();
                const reactions = post.reactions || {};
                let likeCount = 0, loveCount = 0, laughCount = 0;
                Object.values(reactions).forEach(r => {
                  if (r.type === 'like') likeCount++;
                  if (r.type === 'love') loveCount++;
                  if (r.type === 'laugh') laughCount++;
                });
                const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
                const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
                const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
                if (likeCountEl) likeCountEl.textContent = likeCount;
                if (loveCountEl) loveCountEl.textContent = loveCount;
                if (laughCountEl) laughCountEl.textContent = laughCount;
              }
            });
          }
        });
      }
    });

    // Add event listener for comment buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const content = commentInput.value.trim();
        if (content) {
          addComment(postId, content);
          commentInput.value = '';
        }
      }
    });
    
    // Function to add a comment to Firestore
    function addComment(postId, content) {
      const user = auth.currentUser;
      if (!user) return;
    
      const comment = {
        authorId: user.uid,
        authorName: user.displayName || "Unknown User",
        content: content,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      };
    
      db.collection('posts').doc(postId).collection('comments').add(comment)
        .then(() => {
          loadComments(postId);
        })
        .catch((error) => {
          console.error("Error adding comment: ", error);
        });
    }

    // Function to load comments for a post
    function loadComments(postId) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Get the current user's friends (including themselves)
      db.collection('friends').doc(user.uid).get()
        .then((friendsDoc) => {
          const friends = friendsDoc.data()?.friends || [];
          const friendIds = friends.map(friend => friend.uid);
          friendIds.push(user.uid); // Include the current user
    
          // Fetch all comments for the post
          db.collection('posts').doc(postId).collection('comments')
            .orderBy('timestamp', 'asc')
            .get()
            .then((querySnapshot) => {
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.innerHTML = '';
              const commentPromises = [];
    
              querySnapshot.forEach((doc) => {
                const comment = doc.data();
                // Only show comments from friends
                if (friendIds.includes(comment.authorId)) {
                  const promise = getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                    const commentHTML = `
                      <div class="comment">
                        <div class="comment-author-picture">
                          ${profilePictureHTML}
                        </div>
                        <div class="comment-content">
                          <div class="comment-author-name">${comment.authorName}</div>
                          <div>${comment.content}</div>
                        </div>
                      </div>
                    `;
                    commentsList.innerHTML += commentHTML;
                  });
                  commentPromises.push(promise);
                }
              });
    
              return Promise.all(commentPromises);
            })
            .catch((error) => {
              console.error("Error loading comments: ", error);
            });
        })
        .catch((error) => {
          console.error("Error fetching friends: ", error);
        });
    }
    
    // Function to get the author's profile picture for comments
    function getCommentAuthorPicture(authorId, authorName) {
      return db.collection('users').doc(authorId).get().then((userDoc) => {
        if (userDoc.exists) {
          const userData = userDoc.data();
          const profilePictureURL = userData.profilePictureURL;
          if (profilePictureURL) {
            return `<img src="${profilePictureURL}" alt="Profile Picture" class="comment-author-picture">`;
          } else {
            // Use displayName for the initials fallback
            return getInitialsFallback(authorName || "Unknown User");
          }
        } else {
          return getInitialsFallback("Unknown User");
        }
      }).catch(() => {
        return getInitialsFallback("Unknown User");
      });
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString(); // You can customize the format as needed
    }

    // Function to log the current user's friends and their posts to the console
    async function logUserFriendsWithPosts(userId) {
        let friendIds = [];
        try {
            // Log the current user and their posts
            const userPostsSnapshot = await db.collection('posts')
                .where('authorId', '==', userId)
                .orderBy('timestamp', 'desc')
                .get();
    
            const userPosts = userPostsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
    
            console.log(`- User: ${auth.currentUser.displayName || "Current User"}`);
            if (userPosts.length > 0) {
                console.log("  Posts:");
                userPosts.forEach(post => {
                    console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                });
            } else {
                console.log("  No posts found.");
            }
    
            // Log the user's friends and their posts
            const friendsDoc = await db.collection('friends').doc(userId).get();
            if (friendsDoc.exists) {
                friendIds = friendsDoc.data()?.friends.map(friend => friend.uid) || [];
                for (const friend of friendIds) {
                    const postsSnapshot = await db.collection('posts')
                        .where('authorId', '==', friend)
                        .orderBy('timestamp', 'desc')
                        .get();
    
                    const posts = postsSnapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
    
                    console.log(`- Friend: ${friend}`);
                    if (posts.length > 0) {
                        console.log("  Posts:");
                        posts.forEach(post => {
                            console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                        });
                    } else {
                        console.log("  No posts found.");
                    }
                }
            } else {
                console.log("No friends document found for this user.");
            }
        } catch (error) {
            console.error("Error fetching user/friends or posts:", error);
        }
        return friendIds; // Return the list of friend IDs
    }

    // Throttle function to limit how often the scroll event fires
    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function() {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                    if ((Date.now() - lastRan) >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
    
    // Function to check if the user has scrolled to the bottom
    function isAtBottom() {
        return (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200;
    }

    // Replace your setupIntersectionObserver with this:
    function setupIntersectionObserver() {
      const options = {
        root: null,
        rootMargin: '0px',
        threshold: 0.1,
      };
    
      const observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting && entry.target === feed.lastElementChild) {
            loadPosts();
          }
        });
      }, options);
    
      // Observe only the last post
      const posts = document.querySelectorAll('.post');
      if (posts.length > 0) {
        observer.observe(posts[posts.length - 1]);
      }
    }

    document.querySelectorAll('.orientation-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.orientation-button').forEach(b => b.classList.remove('selected'));
        button.classList.add('selected');
      });
    });

    const getSelectedOrientation = () => {
      const selectedButton = document.querySelector('.orientation-button.selected');
      return selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    };

    // Add this near your other event listeners
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-post-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const confirmDelete = confirm('Are you sure you want to delete this post?');
        if (confirmDelete) {
          deletePost(postId);
        }
      }
    });
    
    // Define the deletePost function
    async function deletePost(postId) {
      try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) {
          console.error('Post does not exist');
          return;
        }
    
        const postData = postDoc.data();
        const storage = firebase.storage();
    
        // Delete media from Storage if it exists
        if (postData.photoURL) {
          const photoRef = storage.refFromURL(postData.photoURL);
          await photoRef.delete();
        }
        if (postData.videoURL) {
          const videoRef = storage.refFromURL(postData.videoURL);
          await videoRef.delete();
        }
    
        // Delete the post document
        await postRef.delete();
    
        // Remove the post from the UI
        const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
        if (postElement) {
          postElement.remove();
        }
    
        alert('Post deleted successfully!');
      } catch (error) {
        console.error('Error deleting post:', error);
        alert(translations[userLanguage]["Failed to delete post. Please try again."]);
      }
    }

    postMedia.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) {
            document.getElementById('image-preview-container').style.display = 'none';
            document.getElementById('video-preview-container').style.display = 'none';
            return;
        }
    
        // Reset the media input and previews
        document.getElementById('image-preview-container').style.display = 'none';
        document.getElementById('video-preview-container').style.display = 'none';
    
        if (file.type.startsWith('image/')) {
            // Handle image
            const reader = new FileReader();
            reader.onload = (e) => {
                const preview = document.getElementById('image-preview');
                const previewContainer = document.getElementById('image-preview-container');
                preview.src = e.target.result;
                previewContainer.style.display = 'block';
    
                const modal = document.getElementById('image-cropper-modal');
                const cropperImage = document.getElementById('cropper-image');
                cropperImage.src = e.target.result;
                modal.style.display = 'block';
    
                // Initialize Cropper.js (your existing code)
                let cropperAspectRatio = 16 / 9;
                let cropper = new Cropper(cropperImage, {
                    aspectRatio: cropperAspectRatio,
                    viewMode: 1,
                    dragMode: 'move',
                    guides: true,
                    highlight: false,
                    cropBoxMovable: true,
                    cropBoxResizable: true,
                    modal: true,
                });
    
                // Toggle orientation buttons (your existing code)
                document.querySelectorAll('.crop-orientation-button').forEach(button => {
                    button.addEventListener('click', () => {
                        document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
                        button.classList.add('selected');
                        const orientation = button.getAttribute('data-orientation');
                        cropperAspectRatio = orientation === 'horizontal' ? 16 / 9 : 9 / 16;
                        cropper.setAspectRatio(cropperAspectRatio);
                    });
                });
    
                // Handle "Done" button (your existing code)
                document.getElementById('crop-done-button').onclick = () => {
                    const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
                    let width, height;
                    if (selectedOrientation === 'horizontal') {
                        width = 1200;  // Larger dimensions for better quality
                        height = 675;  // 16:9
                        quality = 0.92;
                        mimeType = 'image/jpeg';
                    } else {
                        width = 720;   // Larger dimensions for vertical images
                        height = 1280; // 9:16 (or use original dimensions)
                        quality = 1;   // Maximum quality for vertical images
                        mimeType = 'image/png';
                    }
                    const canvas = cropper.getCroppedCanvas({ width, height, fillColor: '#fff', imageSmoothingEnabled: true, imageSmoothingQuality: 'high' });
                    canvas.toBlob(
                      (blob) => {
                        const croppedFile = new File([blob], file.name, { type: 'image/jpeg' });
                        const dataTransfer = new DataTransfer();
                        dataTransfer.items.add(croppedFile);
                        postMedia.files = dataTransfer.files;
                        postMedia.setAttribute('data-orientation', selectedOrientation);
                        postMedia.setAttribute('data-type', 'image');
                        modal.style.display = 'none';
                        cropper.destroy();
                      },
                      'image/jpeg',
                      quality  // Use dynamic quality
                    );
                };
    
                // Handle "Cancel" button
                document.getElementById('crop-cancel-button').onclick = () => {
                    modal.style.display = 'none';
                    cropper.destroy();
                    postMedia.value = '';
                    document.getElementById('image-preview-container').style.display = 'none';
                    document.getElementById('video-preview-container').style.display = 'none';
                };
            };
            reader.readAsDataURL(file);
        } else if (file.type.startsWith('video/')) {
            // Handle video preview
            checkVideoDuration(file, (isValid) => {
                if (!isValid) {
                    errorMessage.textContent = translations[userLanguage]["Video must be 10 seconds or shorter."];
                    postMedia.value = '';
                    document.getElementById('video-preview-container').style.display = 'none';
                } else {
                    const videoPreview = document.getElementById('video-preview');
                    const videoPreviewContainer = document.getElementById('video-preview-container');
                    videoPreview.src = URL.createObjectURL(file);
                    videoPreviewContainer.style.display = 'block';
                    postMedia.setAttribute('data-type', 'video');
                    postMedia.setAttribute('data-orientation', 'vertical');
                }
            });
        }
    });

    function checkVideoDuration(file, callback) {
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.onloadedmetadata = () => {
        window.URL.revokeObjectURL(video.src);
        callback(video.duration <= 10);
      };
      video.src = URL.createObjectURL(file);
    }

    // Load posts when page loads
    window.onload = loadPosts;

    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('ServiceWorker registration successful');
            // Force update check
            registration.update();
          })
          .catch((err) => {
            console.log('ServiceWorker registration failed: ', err);
          });
      });
    }

    let userLanguage = "English"; // Define globally
    // Update placeholders
    document.getElementById('post-content').placeholder = translations[userLanguage]["How's life treating ya?"];
    document.querySelectorAll('.comment-input').forEach(input => {
      input.placeholder = translations[userLanguage]["Write a comment..."];
    });

    // Translations dictionary
    const translations = {
      English: {
        "Create a Post": "Create a Post",
        "How's life treating ya?": "How's life treating ya?",
        "Photo/Video": "Photo/Video",
        "Post": "Post",
        "Adjust Image": "Adjust Image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Done",
        "Cancel": "Cancel",
        "Video must be 10 seconds or shorter.": "Video must be 10 seconds or shorter.",
        "Post created!": "Post created!",
        "Are you sure you want to delete this post?": "Are you sure you want to delete this post?",
        "Post deleted successfully!": "Post deleted successfully!",
        "Failed to delete post. Please try again.": "Failed to delete post. Please try again.",
        "Your Feed": "Your Feed",
        "Feed": "Feed",
        "Profile": "Profile",
        "Post content cannot be empty.": "Post content cannot be empty.",
        "Write a comment...": "Write a comment...",
        "Transaction failed: ": "Transaction failed: ",
      },
      French: {
        "Create a Post": "Cr√©er une publication",
        "How's life treating ya?": "Comment √ßa va ?",
        "Photo/Video": "Photo/Vid√©o",
        "Post": "Publier",
        "Adjust Image": "Ajuster l'image",
        "Horizontal": "Horizontal",
        "Vertical": "Vertical",
        "Done": "Termin√©",
        "Cancel": "Annuler",
        "Video must be 10 seconds or shorter.": "La vid√©o doit durer 10 secondes ou moins.",
        "Post created!": "Publication cr√©√©e !",
        "Are you sure you want to delete this post?": "√ätes-vous s√ªr de vouloir supprimer cette publication ?",
        "Post deleted successfully!": "Publication supprim√©e avec succ√®s !",
        "Failed to delete post. Please try again.": "√âchec de la suppression de la publication. Veuillez r√©essayer.",
        "Your Feed": "Votre fil d'actualit√©",
        "Feed": "Fil d'actualit√©",
        "Profile": "Profil",
        "Post content cannot be empty.": "Le contenu de la publication ne peut pas √™tre vide.",
        "Write a comment...": "√âcrivez un commentaire...",
        "Transaction failed: ": "√âchec de la transaction : ",
      },
      Korean: {
        "Create a Post": "Í≤åÏãúÎ¨º ÏûëÏÑ±",
        "How's life treating ya?": "ÏöîÏ¶ò Ïñ¥ÎñªÍ≤å ÏßÄÎÇ¥ÏÑ∏Ïöî?",
        "Photo/Video": "ÏÇ¨ÏßÑ/ÎπÑÎîîÏò§",
        "Post": "Í≤åÏãú",
        "Adjust Image": "Ïù¥ÎØ∏ÏßÄ Ï°∞Ï†ï",
        "Horizontal": "Í∞ÄÎ°ú",
        "Vertical": "ÏÑ∏Î°ú",
        "Done": "ÏôÑÎ£å",
        "Cancel": "Ï∑®ÏÜå",
        "Video must be 10 seconds or shorter.": "ÎπÑÎîîÏò§Îäî 10Ï¥à Ïù¥ÌïòÏó¨Ïïº Ìï©ÎãàÎã§.",
        "Post created!": "Í≤åÏãúÎ¨ºÏù¥ ÏûëÏÑ±ÎêòÏóàÏäµÎãàÎã§!",
        "Are you sure you want to delete this post?": "Ïù¥ Í≤åÏãúÎ¨ºÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
        "Post deleted successfully!": "Í≤åÏãúÎ¨ºÏù¥ ÏÑ±Í≥µÏ†ÅÏúºÎ°ú ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§!",
        "Failed to delete post. Please try again.": "Í≤åÏãúÎ¨º ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌï¥ Ï£ºÏÑ∏Ïöî.",
        "Your Feed": "ÌîºÎìú",
        "Feed": "ÌîºÎìú",
        "Profile": "ÌîÑÎ°úÌïÑ",
        "Post content cannot be empty.": "Í≤åÏãúÎ¨º ÎÇ¥Ïö©Ïù¥ ÎπÑÏñ¥ ÏûàÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.",
        "Write a comment...": "ÎåìÍ∏ÄÏùÑ ÏûëÏÑ±ÌïòÏÑ∏Ïöî...",
        "Transaction failed: ": "Ìä∏ÎûúÏû≠ÏÖò Ïã§Ìå®: ",
      }
    };
    
    // Function to update the page language
    function updatePageLanguage(language) {
      const lang = translations[language] || translations["English"];
      document.querySelectorAll("[data-i18n]").forEach((element) => {
        const key = element.getAttribute("data-i18n");
        if (lang[key]) {
          element.textContent = lang[key];
        }
      });
    }

  </script>
</body>
</html>
