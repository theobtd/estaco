<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Estaco - Home Feed</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/cropperjs/1.5.12/cropper.min.js"></script>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/css/splide.min.css">
  <script src="https://cdn.jsdelivr.net/npm/@splidejs/splide@4.1.4/dist/js/splide.min.js"></script>
  <style>
    body {
      font-family: Arial, sans-serif;
      max-width: 600px;
      margin: 0 auto;
      padding: 20px;
    }
    #post-form {
      margin-bottom: 20px;
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
    }
    #post-content, #post-photo {
      width: 100%;
      padding: 8px;
      margin: 5px 0;
    }
    #post-button {
      background-color: #4CAF50;
      color: white;
      padding: 10px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    #feed {
      margin-top: 20px;
    }
    .post {
      padding: 10px;
      border: 1px solid #ddd;
      border-radius: 5px;
      margin-bottom: 10px;
    }
    #error-message {
      color: red;
    }
    .post-header {
      display: flex;
      align-items: center;
      margin-bottom: 10px;
    }
    .post-author-picture {
      width: 40px;
      height: 40px;
      border-radius: 15%;
      margin-right: 10px;
    }
    .reactions {
      margin-top: 10px;
    }
    .reaction-button {
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      margin-right: 5px;
    }
    .reaction-count {
      font-size: 12px;
      margin-left: 3px;
      color: #666;
    }
    .reaction-button.selected {
      background-color: #f0f0f0;
      border-radius: 4px;
      padding: 2px 4px;
    }
    .comments-section {
      margin-top: 10px;
      border-top: 1px solid #eee;
      padding-top: 10px;
    }
    .comment-form {
      display: flex;
      margin-bottom: 10px;
    }
    .comment-input {
      flex: 1;
      padding: 8px;
      border: 1px solid #ddd;
      border-radius: 4px;
    }
    .comment-button {
      padding: 8px 12px;
      background: #4CAF50;
      color: white;
      border: none;
      border-radius: 4px;
      margin-left: 5px;
      cursor: pointer;
    }
    .comment {
      display: flex;
      margin-bottom: 8px;
      align-items: flex-start;
    }
    .comment-author-picture {
      width: 30px;
      height: 30px;
      border-radius: 10%; /* Adjust this value to control the roundness */
      margin-right: 8px;
    }
    .comment-content {
      background: #f9f9f9;
      padding: 8px 12px;
      border-radius: 8px;
      flex: 1;
    }
    .comment-author-name {
      font-weight: bold;
      margin-bottom: 2px;
    }
    .post-timestamp {
      text-align: right;
      font-size: 12px;
      color: #666;
      margin-top: -15px; /* Adjust as needed to move it closer to the header */
    }
    .media-container {
      position: relative;
      margin-top: 10px;
      overflow: hidden;
      background-color: #f0f0f0; /* Placeholder color */
    }
    .media-horizontal {
      width: 100%;
      max-width: 600px;
      height: 400px;
      position: relative;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    
    .media-vertical {
      width: 100%;
      max-width: 400px;
      height: 600px;
      margin: 0 auto;
      position: relative;
      overflow: hidden;
      background-color: #f0f0f0;
    }
    .orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .orientation-button.selected {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }
    .media-container img,
    .media-container video {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      object-fit: contain; /* Use contain instead of cover */
      background-color: #f0f0f0; /* Placeholder color */
    }
    .delete-post-button {
      background: #f44336;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 4px 8px;
      cursor: pointer;
      font-size: 12px;
    }
    .crop-orientation-button {
      padding: 8px 12px;
      margin-right: 5px;
      border: 1px solid #ddd;
      border-radius: 4px;
      background: #f9f9f9;
      cursor: pointer;
    }
    .crop-orientation-button.selected {
      background: #4CAF50;
      color: white;
      border-color: #4CAF50;
    }

    .splide__slide img {
        width: 100%;
        height: 100%;
        object-fit: contain;
    }
    .splide__arrow {
        background: rgba(0, 0, 0, 0.5);
        border-radius: 50%;
        width: 40px;
        height: 40px;
    }
    .splide__pagination {
        bottom: 10px;
    }

  </style>
</head>
<body>
  <h1>Estaco - Home Feed</h1>

  <button id="profile-button" style="margin-top: 20px;">Go to Profile</button>

  <div id="post-form">
      <h3>Create a Post</h3>
      <textarea id="post-content" placeholder="What's on your mind?" rows="3"></textarea>
      <input type="file" id="post-photo" accept="image/*" multiple>
      <div id="image-preview" style="display: flex; flex-wrap: wrap; gap: 10px; margin: 10px 0;"></div>
      <input type="file" id="post-video" accept="video/*">
      <div id="video-orientation-buttons" style="display: none; margin: 10px 0;">
        <button class="orientation-button selected" data-orientation="horizontal">Horizontal</button>
        <button class="orientation-button" data-orientation="vertical">Vertical</button>
      </div>
      <button id="post-button">Post</button>
      <p id="error-message"></p>
  </div>

  <div id="image-cropper-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 1000;">
    <div style="max-width: 500px; margin: 20px auto; background: white; padding: 20px; border-radius: 10px;">
      <h3>Adjust Image</h3>
      <div style="margin-bottom: 10px;">
        <button class="crop-orientation-button selected" data-orientation="horizontal">Horizontal</button>
        <button class="crop-orientation-button" data-orientation="vertical">Vertical</button>
      </div>
      <div style="width: 100%; height: 400px;">
        <img id="cropper-image" style="max-width: 100%;">
      </div>
      <button id="crop-done-button" style="margin-top: 10px; padding: 8px 12px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">Done</button>
      <button id="crop-cancel-button" style="margin-top: 10px; padding: 8px 12px; background: #f44336; color: white; border: none; border-radius: 4px; cursor: pointer; margin-left: 10px;">Cancel</button>
    </div>
  </div>
  
  <div id="feed">
    <h3>Your Feed</h3>
  </div>


  <!-- Firebase SDK -->
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-auth-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-firestore-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/9.6.0/firebase-storage-compat.js"></script>
  <script>
    // Your Firebase config (replace with your own)
    const firebaseConfig = {
      apiKey: "AIzaSyB1txjASKb_6VPhKBpQh_Y3hoPHsNWwZ_0",
      authDomain: "estaco-add3c.firebaseapp.com",
      projectId: "estaco-add3c",
      storageBucket: "estaco-add3c.firebasestorage.app",
      messagingSenderId: "876337002297",
      appId: "1:876337002297:web:b410c373bd857bc7cd1ae8"
    };

    // Initialize Firebase
    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();
    const storage = firebase.storage();

    // DOM elements
    const postContent = document.getElementById('post-content');
    const postPhoto = document.getElementById('post-photo');
    const postButton = document.getElementById('post-button');
    const postVideo = document.getElementById('post-video');
    const feed = document.getElementById('feed');
    const errorMessage = document.getElementById('error-message');

    let isLoading = false; // Flag to prevent multiple simultaneous loads
    let selectedImageFiles = []; // Global array to store selected images
    
    // Navigate to Profile Page
    const profileButton = document.getElementById('profile-button');
    profileButton.addEventListener('click', () => {
        window.location.href = 'profile.html';
    });

    // Check if user is signed in and verified
    auth.onAuthStateChanged((user) => {
        if (!user || !user.emailVerified) {
            alert('Please sign in and verify your email to access the home feed.');
            window.location.href = 'index.html';
        } else {
            logUserFriendsWithPosts(user.uid); // Call the new function
            loadPosts();
        }
    });

    // Create a new post
    postButton.addEventListener('click', () => {
      const content = postContent.value;
      const videoFile = postVideo.files[0];
    
      if (!content && selectedImageFiles.length === 0 && !videoFile) {
        errorMessage.textContent = 'Post content cannot be empty.';
        return;
      }
    
      const user = auth.currentUser;
      user.reload().then(() => {
        const authorName = user.displayName || "Unknown User";
        const post = {
          authorId: user.uid,
          authorName: authorName,
          content: content,
          timestamp: firebase.firestore.FieldValue.serverTimestamp(),
          reactions: {},
          imageURLs: [], // Initialize as empty array
        };
    
        // Upload post to Firestore
        db.collection('posts').add(post)
          .then((docRef) => {
            const uploadPromises = [];
    
            // Upload all images
            if (selectedImageFiles.length > 0) {
              selectedImageFiles.forEach((file, index) => {
                const storageRef = storage.ref();
                const photoRef = storageRef.child(`postPhotos/${docRef.id}_${index}`);
                const uploadTask = photoRef.put(file);
                uploadPromises.push(
                  new Promise((resolve, reject) => {
                    uploadTask.on('state_changed',
                      null,
                      (error) => {
                        console.error('Upload error:', error);
                        reject(error);
                      },
                      () => {
                        uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                          post.imageURLs.push(downloadURL);
                          resolve();
                        });
                      }
                    );
                  })
                );
              });
            }
    
            // Upload video if present (unchanged)
            if (videoFile) {
              const storageRef = storage.ref();
              const videoRef = storageRef.child(`postVideos/${docRef.id}`);
              const uploadTask = videoRef.put(videoFile);
              uploadPromises.push(
                new Promise((resolve, reject) => {
                  uploadTask.on('state_changed',
                    null,
                    (error) => {
                      console.error('Upload error:', error);
                      reject(error);
                    },
                    () => {
                      uploadTask.snapshot.ref.getDownloadURL().then((downloadURL) => {
                        docRef.update({
                          videoURL: downloadURL,
                          mediaOrientation: getSelectedOrientation()
                        }).then(resolve);
                      });
                    }
                  );
                })
              );
            }
    
            // Wait for all uploads to complete
            Promise.all(uploadPromises)
              .then(() => {
                if (post.imageURLs.length > 0) {
                  docRef.update({ imageURLs: post.imageURLs });
                }
                alert('Post created!');
                postContent.value = '';
                postPhoto.value = '';
                postVideo.value = '';
                selectedImageFiles = []; // Clear the array
                loadPosts();
              })
              .catch((error) => {
                errorMessage.textContent = error.message;
              });
          })
          .catch((error) => {
            errorMessage.textContent = error.message;
          });
      });
    });

    let lastVisiblePost = null; // To keep track of the last fetched post
    const postLimit = 3; // Number of posts to load at a time
    let isFirstLoad = true; // Add this flag at the top with your other variables
    
    async function loadPosts() {
        if (isLoading) return; // Prevent multiple simultaneous loads
        isLoading = true;
    
        const user = auth.currentUser;
        if (!user) {
            isLoading = false;
            return;
        }
    
        const friendIds = await logUserFriendsWithPosts(user.uid);
        friendIds.push(user.uid);
    
        let query = db.collection('posts')
            .where('authorId', 'in', friendIds)
            .orderBy('timestamp', 'desc');
    
        if (lastVisiblePost) {
            query = query.startAfter(lastVisiblePost);
        }
    
        // Load only 1 post on the first load
        if (isFirstLoad) {
            query = query.limit(1);
        } else {
            query = query.limit(postLimit);
        }
    
        query.get().then((querySnapshot) => {
            if (querySnapshot.empty) {
                if (!feed.querySelector('.post')) {
                    feed.innerHTML = '<p>No posts yet. Create one!</p>';
                } else {
                    feed.innerHTML += '<p>No more posts to load.</p>';
                }
                isLoading = false;
                return;
            }
    
            const postsData = [];
            querySnapshot.forEach((doc) => {
                const post = doc.data();
                post.id = doc.id;
                postsData.push(post);
                lastVisiblePost = doc; // Update lastVisiblePost for pagination
            });
    
            renderPosts(postsData);
    
            // After the first load, set the flag to false and load more posts
            if (isFirstLoad) {
                isFirstLoad = false;
                setTimeout(() => loadPosts(), 100); // Small delay to ensure DOM is ready
            }
    
            isLoading = false;
        }).catch((error) => {
            errorMessage.textContent = error.message;
            isLoading = false;
        });
    }
    
    // Function to render posts
    function renderPosts(postsData) {
        postsData.forEach((post) => {
            const profilePictureURL = post.authorData && post.authorData.profilePictureURL ? post.authorData.profilePictureURL : null;
            const profilePictureHTML = profilePictureURL ? 
                `<img src="${profilePictureURL}" alt="Profile Picture" class="post-author-picture">` : 
                getInitialsFallback(post.authorName);
    
            // Get the current user's reaction for this post
            const userReaction = post.reactions && post.reactions[auth.currentUser.uid];
            const likeClass = userReaction === 'like' ? 'selected' : '';
            const loveClass = userReaction === 'love' ? 'selected' : '';
            const laughClass = userReaction === 'laugh' ? 'selected' : '';
    
            const reactions = post.reactions || {};
            let likeCount = 0, loveCount = 0, laughCount = 0;
            Object.values(reactions).forEach(reaction => {
                if (reaction === 'like') likeCount++;
                if (reaction === 'love') loveCount++;
                if (reaction === 'laugh') laughCount++;
            });
    
            const isAuthor = auth.currentUser && auth.currentUser.uid === post.authorId;
            const likeCountHTML = isAuthor ? `<span class="reaction-count">${likeCount}</span>` : '';
            const loveCountHTML = isAuthor ? `<span class="reaction-count">${loveCount}</span>` : '';
            const laughCountHTML = isAuthor ? `<span class="reaction-count">${laughCount}</span>` : '';

            let mediaHTML = '';
            if (post.imageURLs && post.imageURLs.length > 0) {
                const orientation = post.mediaOrientation || 'horizontal';
                mediaHTML = `
                    <div class="media-container media-${orientation}">
                        <div class="splide">
                            <div class="splide__track">
                                <ul class="splide__list">
                                    ${post.imageURLs.map(url => `
                                        <li class="splide__slide">
                                            <img src="${url}" class="post-media" alt="Post Image">
                                        </li>
                                    `).join('')}
                                </ul>
                            </div>
                        </div>
                    </div>
                `;
            } else if (post.videoURL) {
                const orientation = post.mediaOrientation || 'horizontal'; // Default to horizontal
                mediaHTML = `
                  <div class="media-container media-${orientation}">
                    <video controls class="post-media">
                      <source src="${post.videoURL}" type="video/mp4">
                    </video>
                  </div>
                `;
            }

    
            let postHTML = `
                <div class="post" data-post-id="${post.id}">
                    <div class="post-header" style="display: flex; justify-content: space-between; align-items: center;">
                        <div style="display: flex; align-items: center;">
                            ${profilePictureHTML}
                            <h4 style="margin: 0;">${post.authorName}</h4>
                        </div>
                        <div style="display: flex; align-items: center;">
                            <span style="font-size: 12px; color: #666; margin-right: 10px;">${formatTimestamp(post.timestamp.toDate())}</span>
                            ${isAuthor ? `<button class="delete-post-button" data-post-id="${post.id}" style="background: #f44336; color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer;">Delete</button>` : ''}
                        </div> 
                    </div>
                    <p>${post.content}</p>
                    ${mediaHTML}
                    <div class="reactions">
                        <button class="reaction-button ${likeClass}" data-post-id="${post.id}" data-reaction="like">üëç${likeCountHTML}</button>
                        <button class="reaction-button ${loveClass}" data-post-id="${post.id}" data-reaction="love">‚ù§Ô∏è${loveCountHTML}</button>
                        <button class="reaction-button ${laughClass}" data-post-id="${post.id}" data-reaction="laugh">üòÇ${laughCountHTML}</button>
                    </div>
                    <div class="comments-section">
                        <div class="comment-form">
                            <input type="text" class="comment-input" placeholder="Write a comment..." data-post-id="${post.id}">
                            <button class="comment-button" data-post-id="${post.id}">Post</button>
                        </div>
                        <div class="comments-list" id="comments-${post.id}">
                            <!-- Comments will be loaded here -->
                        </div>
                    </div>
                </div>
            `;
    
            // Append each post directly to the feed
            feed.innerHTML += postHTML;

            // Initialize Splide for this post if it has multiple images
            if (post.imageURLs && post.imageURLs.length > 1) {
                setTimeout(() => {
                    const splide = new Splide(`.post[data-post-id="${post.id}"] .splide`, {
                        type: 'loop',
                        perPage: 1,
                        arrows: true,
                        pagination: true,
                    }).mount();
                }, 100);
            }
    
            // Load comments for each post
            loadComments(post.id);
        });
        setupIntersectionObserver();
    }
    
    // Call loadPosts initially to load the first batch
    loadPosts();

    function getInitialsFallback(name) {
      const firstLetter = name.charAt(0).toUpperCase();
      const pastelColors = ['#FFD1DC', '#FFE4B5', '#B5EAD7', '#C7CEEA', '#E2F0CB', '#FFB7B2'];
      const colorIndex = name.charCodeAt(0) % pastelColors.length;
      const backgroundColor = pastelColors[colorIndex];
      return `
        <div style="
          width: 40px;
          height: 40px;
          border-radius: 15%;
          background-color: ${backgroundColor};
          display: flex;
          align-items: center;
          justify-content: center;
          color: #333;
          font-weight: bold;
          font-size: 20px;
          margin-right: 10px;
        ">
          ${firstLetter}
        </div>
      `;
    }

    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('reaction-button')) {
        const button = e.target;
        const postId = button.getAttribute('data-post-id');
        const reaction = button.getAttribute('data-reaction');
        const user = auth.currentUser;
        if (!user) return;
    
        // Optimistic UI update: Assume success
        const postRef = db.collection('posts').doc(postId);
        const wasSelected = button.classList.contains('selected');
    
        // Toggle the selected class
        const likeButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="like"]`);
        const loveButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="love"]`);
        const laughButton = document.querySelector(`.reaction-button[data-post-id="${postId}"][data-reaction="laugh"]`);
    
        // Reset all buttons
        if (likeButton) likeButton.classList.remove('selected');
        if (loveButton) loveButton.classList.remove('selected');
        if (laughButton) laughButton.classList.remove('selected');
    
        // Select the clicked button (unless it was already selected)
        if (!wasSelected) {
          button.classList.add('selected');
        }
    
        // Only update counts for the author's posts
        db.collection('posts').doc(postId).get().then((doc) => {
          if (doc.exists) {
            const post = doc.data();
            if (post.authorId === user.uid) {
              // Count reactions
              const reactions = post.reactions || {};
              let likeCount = 0, loveCount = 0, laughCount = 0;
              Object.values(reactions).forEach(r => {
                if (r === 'like') likeCount++;
                if (r === 'love') loveCount++;
                if (r === 'laugh') laughCount++;
              });
    
              // Get the previous reaction (if any)
              const prevReaction = reactions[user.uid];
    
              // If there was a previous reaction, decrement its count
              if (prevReaction) {
                if (prevReaction === 'like') likeCount--;
                if (prevReaction === 'love') loveCount--;
                if (prevReaction === 'laugh') laughCount--;
              }
    
              // If the clicked button was not selected, increment its count
              if (!wasSelected) {
                if (reaction === 'like') likeCount++;
                if (reaction === 'love') loveCount++;
                if (reaction === 'laugh') laughCount++;
              }
    
              // Update the UI for the author
              const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
              const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
              const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
    
              if (likeCountEl) likeCountEl.textContent = likeCount;
              if (loveCountEl) loveCountEl.textContent = loveCount;
              if (laughCountEl) laughCountEl.textContent = laughCount;
            }
          }
        });
    
        // Perform the Firestore transaction
        db.runTransaction((transaction) => {
          return transaction.get(postRef).then((doc) => {
            if (!doc.exists) throw "Post does not exist!";
            const postData = doc.data();
            const reactions = postData.reactions || {};
            const userReaction = reactions[user.uid];
    
            if (userReaction === reaction) {
              delete reactions[user.uid];
            } else {
              reactions[user.uid] = reaction;
            }
    
            transaction.update(postRef, { reactions });
          });
        }).catch((error) => {
          console.error("Transaction failed: ", error);
          // Revert UI on failure
          if (likeButton) likeButton.classList.remove('selected');
          if (loveButton) loveButton.classList.remove('selected');
          if (laughButton) laughButton.classList.remove('selected');
          if (!wasSelected) {
            if (reaction === 'like' && likeButton) likeButton.classList.add('selected');
            if (reaction === 'love' && loveButton) loveButton.classList.add('selected');
            if (reaction === 'laugh' && laughButton) laughButton.classList.add('selected');
          }
          // Revert count for author
          if (post.authorId === user.uid) {
            db.collection('posts').doc(postId).get().then((doc) => {
              if (doc.exists) {
                const post = doc.data();
                const reactions = post.reactions || {};
                let likeCount = 0, loveCount = 0, laughCount = 0;
                Object.values(reactions).forEach(r => {
                  if (r === 'like') likeCount++;
                  if (r === 'love') loveCount++;
                  if (r === 'laugh') laughCount++;
                });
                const likeCountEl = likeButton ? likeButton.querySelector('.reaction-count') : null;
                const loveCountEl = loveButton ? loveButton.querySelector('.reaction-count') : null;
                const laughCountEl = laughButton ? laughButton.querySelector('.reaction-count') : null;
                if (likeCountEl) likeCountEl.textContent = likeCount;
                if (loveCountEl) loveCountEl.textContent = loveCount;
                if (laughCountEl) laughCountEl.textContent = laughCount;
              }
            });
          }
        });
      }
    });

    // Add event listener for comment buttons
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('comment-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const commentInput = document.querySelector(`.comment-input[data-post-id="${postId}"]`);
        const content = commentInput.value.trim();
        if (content) {
          addComment(postId, content);
          commentInput.value = '';
        }
      }
    });
    
    // Function to add a comment to Firestore
    function addComment(postId, content) {
      const user = auth.currentUser;
      if (!user) return;
    
      const comment = {
        authorId: user.uid,
        authorName: user.displayName || "Unknown User",
        content: content,
        timestamp: firebase.firestore.FieldValue.serverTimestamp(),
      };
    
      db.collection('posts').doc(postId).collection('comments').add(comment)
        .then(() => {
          loadComments(postId);
        })
        .catch((error) => {
          console.error("Error adding comment: ", error);
        });
    }

    // Function to load comments for a post
    function loadComments(postId) {
      const user = auth.currentUser;
      if (!user) return;
    
      // Get the current user's friends (including themselves)
      db.collection('friends').doc(user.uid).get()
        .then((friendsDoc) => {
          const friends = friendsDoc.data()?.friends || [];
          const friendIds = friends.map(friend => friend.uid);
          friendIds.push(user.uid); // Include the current user
    
          // Fetch all comments for the post
          db.collection('posts').doc(postId).collection('comments')
            .orderBy('timestamp', 'asc')
            .get()
            .then((querySnapshot) => {
              const commentsList = document.getElementById(`comments-${postId}`);
              commentsList.innerHTML = '';
              const commentPromises = [];
    
              querySnapshot.forEach((doc) => {
                const comment = doc.data();
                // Only show comments from friends
                if (friendIds.includes(comment.authorId)) {
                  const promise = getCommentAuthorPicture(comment.authorId, comment.authorName).then((profilePictureHTML) => {
                    const commentHTML = `
                      <div class="comment">
                        <div class="comment-author-picture">
                          ${profilePictureHTML}
                        </div>
                        <div class="comment-content">
                          <div class="comment-author-name">${comment.authorName}</div>
                          <div>${comment.content}</div>
                        </div>
                      </div>
                    `;
                    commentsList.innerHTML += commentHTML;
                  });
                  commentPromises.push(promise);
                }
              });
    
              return Promise.all(commentPromises);
            })
            .catch((error) => {
              console.error("Error loading comments: ", error);
            });
        })
        .catch((error) => {
          console.error("Error fetching friends: ", error);
        });
    }
    
    // Function to get the author's profile picture for comments
    function getCommentAuthorPicture(authorId, authorName) {
      return db.collection('users').doc(authorId).get().then((userDoc) => {
        if (userDoc.exists) {
          const userData = userDoc.data();
          const profilePictureURL = userData.profilePictureURL;
          if (profilePictureURL) {
            return `<img src="${profilePictureURL}" alt="Profile Picture" class="comment-author-picture">`;
          } else {
            // Use displayName for the initials fallback
            return getInitialsFallback(authorName || "Unknown User");
          }
        } else {
          return getInitialsFallback("Unknown User");
        }
      }).catch(() => {
        return getInitialsFallback("Unknown User");
      });
    }

    function formatTimestamp(timestamp) {
      const date = new Date(timestamp);
      return date.toLocaleString(); // You can customize the format as needed
    }

    // Function to log the current user's friends and their posts to the console
    async function logUserFriendsWithPosts(userId) {
        let friendIds = [];
        try {
            // Log the current user and their posts
            const userPostsSnapshot = await db.collection('posts')
                .where('authorId', '==', userId)
                .orderBy('timestamp', 'desc')
                .get();
    
            const userPosts = userPostsSnapshot.docs.map(doc => ({
                id: doc.id,
                ...doc.data()
            }));
    
            console.log(`- User: ${auth.currentUser.displayName || "Current User"}`);
            if (userPosts.length > 0) {
                console.log("  Posts:");
                userPosts.forEach(post => {
                    console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                });
            } else {
                console.log("  No posts found.");
            }
    
            // Log the user's friends and their posts
            const friendsDoc = await db.collection('friends').doc(userId).get();
            if (friendsDoc.exists) {
                friendIds = friendsDoc.data()?.friends.map(friend => friend.uid) || [];
                for (const friend of friendIds) {
                    const postsSnapshot = await db.collection('posts')
                        .where('authorId', '==', friend)
                        .orderBy('timestamp', 'desc')
                        .get();
    
                    const posts = postsSnapshot.docs.map(doc => ({
                        id: doc.id,
                        ...doc.data()
                    }));
    
                    console.log(`- Friend: ${friend}`);
                    if (posts.length > 0) {
                        console.log("  Posts:");
                        posts.forEach(post => {
                            console.log(`  - Post ID: ${post.id}, Content: "${post.content}"`);
                        });
                    } else {
                        console.log("  No posts found.");
                    }
                }
            } else {
                console.log("No friends document found for this user.");
            }
        } catch (error) {
            console.error("Error fetching user/friends or posts:", error);
        }
        return friendIds; // Return the list of friend IDs
    }

    // Throttle function to limit how often the scroll event fires
    function throttle(func, limit) {
        let lastFunc;
        let lastRan;
        return function() {
            const context = this;
            const args = arguments;
            if (!lastRan) {
                func.apply(context, args);
                lastRan = Date.now();
            } else {
                clearTimeout(lastFunc);
                lastFunc = setTimeout(function() {
                    if ((Date.now() - lastRan) >= limit) {
                        func.apply(context, args);
                        lastRan = Date.now();
                    }
                }, limit - (Date.now() - lastRan));
            }
        };
    }
    
    // Function to check if the user has scrolled to the bottom
    function isAtBottom() {
        return (window.innerHeight + window.scrollY) >= document.body.offsetHeight - 200;
    }

    function setupIntersectionObserver() {
        const options = {
            root: null,
            rootMargin: '0px',
            threshold: 0.5 // Trigger when 50% of the post is out of view
        };
    
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (!entry.isIntersecting) {
                    const postElement = entry.target;
                    const postIndex = Array.from(feed.children).indexOf(postElement);
                    // Trigger load if the user scrolls away from post #1, #4, #7, etc.
                    if ((postIndex + 1) % 3 === 1 && !isLoading) {
                        loadPosts();
                    }
                }
            });
        }, options);
    
        // Observe all posts
        document.querySelectorAll('.post').forEach(post => {
            observer.observe(post);
        });
    }

    postVideo.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
    
      checkVideoDuration(file, (isValid) => {
        if (!isValid) {
          errorMessage.textContent = "Video must be 10 seconds or shorter.";
          postVideo.value = ''; // Clear the file input
          document.getElementById('video-orientation-buttons').style.display = 'none';
        } else {
          document.getElementById('video-orientation-buttons').style.display = 'block';
        }
      });
    });

    document.querySelectorAll('.orientation-button').forEach(button => {
      button.addEventListener('click', () => {
        document.querySelectorAll('.orientation-button').forEach(b => b.classList.remove('selected'));
        button.classList.add('selected');
      });
    });

    const getSelectedOrientation = () => {
      const selectedButton = document.querySelector('.orientation-button.selected');
      return selectedButton ? selectedButton.getAttribute('data-orientation') : 'horizontal';
    };

    // Add this near your other event listeners
    document.addEventListener('click', (e) => {
      if (e.target.classList.contains('delete-post-button')) {
        const postId = e.target.getAttribute('data-post-id');
        const confirmDelete = confirm('Are you sure you want to delete this post?');
        if (confirmDelete) {
          deletePost(postId);
        }
      }
    });
    
    // Define the deletePost function
    async function deletePost(postId) {
      try {
        const postRef = db.collection('posts').doc(postId);
        const postDoc = await postRef.get();
        if (!postDoc.exists) {
          console.error('Post does not exist');
          return;
        }
    
        const postData = postDoc.data();
        const storage = firebase.storage();
    
        // Delete media from Storage if it exists
        if (postData.photoURL) {
          const photoRef = storage.refFromURL(postData.photoURL);
          await photoRef.delete();
        }
        if (postData.videoURL) {
          const videoRef = storage.refFromURL(postData.videoURL);
          await videoRef.delete();
        }
    
        // Delete the post document
        await postRef.delete();
    
        // Remove the post from the UI
        const postElement = document.querySelector(`.post[data-post-id="${postId}"]`);
        if (postElement) {
          postElement.remove();
        }
    
        alert('Post deleted successfully!');
      } catch (error) {
        console.error('Error deleting post:', error);
        alert('Failed to delete post. Please try again.');
      }
    }

    postPhoto.addEventListener('change', (event) => {
      const files = Array.from(event.target.files);
      if (files.length > 0) {
        selectedImageFiles.push(...files);
        updateImagePreview();
        const reader = new FileReader();
        reader.onload = (e) => {
          const modal = document.getElementById('image-cropper-modal');
          const cropperImage = document.getElementById('cropper-image');
          cropperImage.src = e.target.result;
          modal.style.display = 'block';
    
          // Default to horizontal
          let cropperAspectRatio = 16 / 9; // Horizontal aspect ratio
    
          // Initialize Cropper.js
          let cropper = new Cropper(cropperImage, {
            aspectRatio: cropperAspectRatio,
            viewMode: 1,
            dragMode: 'move',
            guides: true,
            highlight: false,
            cropBoxMovable: true,
            cropBoxResizable: true,
            modal: true,
          });
    
          // Toggle orientation buttons
          document.querySelectorAll('.crop-orientation-button').forEach(button => {
            button.addEventListener('click', () => {
              document.querySelectorAll('.crop-orientation-button').forEach(b => b.classList.remove('selected'));
              button.classList.add('selected');
    
              // Update cropper aspect ratio
              const orientation = button.getAttribute('data-orientation');
              if (orientation === 'horizontal') {
                cropperAspectRatio = 16 / 9; // Horizontal
              } else {
                cropperAspectRatio = 9 / 16; // Vertical
              }
              cropper.setAspectRatio(cropperAspectRatio);
            });
          });
    
          // Handle "Done" button
          document.getElementById('crop-done-button').onclick = () => {
            const selectedOrientation = document.querySelector('.crop-orientation-button.selected').getAttribute('data-orientation');
            let width, height;
            if (selectedOrientation === 'horizontal') {
              width = 600; // Match .media-horizontal width
              height = 400; // Match .media-horizontal height
            } else {
              width = 400; // Match .media-vertical width
              height = 600; // Match .media-vertical height
            }
          
            // Crop the image to the exact dimensions
            const canvas = cropper.getCroppedCanvas({
              width: width,
              height: height,
              fillColor: '#fff',
              imageSmoothingEnabled: true,
              imageSmoothingQuality: 'high',
            });
          
            canvas.toBlob((blob) => {
              const croppedFile = new File([blob], file.name, { type: 'image/jpeg' });
              const dataTransfer = new DataTransfer();
              dataTransfer.items.add(croppedFile);
              postPhoto.files = dataTransfer.files;
              postPhoto.setAttribute('data-orientation', selectedOrientation);
              modal.style.display = 'none';
              cropper.destroy();
            }, 'image/jpeg');
          };
    
          // Handle "Cancel" button
          document.getElementById('crop-cancel-button').onclick = () => {
            modal.style.display = 'none';
            cropper.destroy();
            postPhoto.value = ''; // Clear the file input
            selectedImageFiles = [];
            updateImagePreview();
          };
        };
        reader.readAsDataURL(file);
      }
    });

    function updateImagePreview() {
      const previewContainer = document.getElementById('image-preview');
      previewContainer.innerHTML = ''; // Clear existing previews
    
      selectedImageFiles.forEach((file, index) => {
        const reader = new FileReader();
        reader.onload = (e) => {
          const img = document.createElement('img');
          img.src = e.target.result;
          img.style.maxWidth = '100px';
          img.style.maxHeight = '100px';
          img.style.borderRadius = '4px';
          img.style.objectFit = 'cover';
          previewContainer.appendChild(img);
        };
        reader.readAsDataURL(file);
      });
    }

    function checkVideoDuration(file, callback) {
      const video = document.createElement('video');
      video.preload = 'metadata';
      video.onloadedmetadata = () => {
        window.URL.revokeObjectURL(video.src);
        callback(video.duration <= 10);
      };
      video.src = URL.createObjectURL(file);
    }

    // Load posts when page loads
    window.onload = loadPosts;
  </script>
</body>
</html>
